//! Return a Box<Iterator<Item=Block>>


#[derive(Clone, Debug)]
pub struct Block {
    index: u32,
}
impl Block {
    pub fn new(index: u32) -> Self {
        Block{
            index
        }
    }
}

#[derive(Debug)]
pub struct BlockCursor{
    items: Vec<Block>,
}
impl BlockCursor {
    pub fn new(items: &Vec<Block>) -> Self {
        return BlockCursor {
            items: items.to_vec(),
        }
    }
}
impl IntoIterator for  BlockCursor {
    type Item = Block;
    type IntoIter = ::std::vec::IntoIter<Block>;

    fn into_iter(self) -> <Self as IntoIterator>::IntoIter {
        self.items.into_iter()
    }
}


pub trait BlockStore {
    fn get_all(&mut self) -> Box<Iterator<Item=Block>>;

    fn get_from_to(&mut self, from: usize, to: usize) -> Box<Iterator<Item=Block>>;
}


pub struct Ledger {
    blocks: Vec<Block>,
}
impl Ledger {
    pub fn new(blocks: Vec<Block>) -> Self {
        Ledger {
            blocks
        }
    }
}
impl BlockStore for Ledger {
    fn get_all(&mut self) -> Box<Iterator<Item=Block>> {
        Box::new(BlockCursor::new(&self.blocks).into_iter())
    }

    fn get_from_to(&mut self, from: usize, to: usize) -> Box<Iterator<Item=Block>> {
        let result: Vec<Block> = self.blocks[from..to].iter().cloned().collect();
        Box::new(BlockCursor::new(&result).into_iter())
    }
}

fn main() {
    let mut blocks: Vec<Block> = vec![];
    blocks.push(Block::new(0));
    blocks.push(Block::new(1));
    blocks.push(Block::new(2));
    blocks.push(Block::new(3));
    blocks.push(Block::new(4));

    let mut ledger = Ledger::new(blocks);


    println!("getAll");
    for block in ledger.get_all() {
        println!("{:?}", block);
    }

    println!("getFromTo");
    for block in ledger.get_from_to(1,4) {
        println!("{:?}", block);
    }
}