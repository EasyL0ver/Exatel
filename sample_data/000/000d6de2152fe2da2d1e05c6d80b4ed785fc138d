import org.jetbrains.annotations.NotNull;

import java.awt.*;
import java.util.InputMismatchException;
import java.util.Scanner;


/*
 *  1. Set size of chess board
 *  2. Create equal amount of lists to chess board size
 *  3. Choose the Knights start location
 *  4. If findPath is true
 *      4.1 Print out path
 *  5. Path not found
 *      5.1 Print line 'Path not found'
 *
 *   Find Path Recursive Method:
 *   1.: End point: If Knight has moved equal to total amount of spots to move on the board, then
 *      1.1.: Return true; Path has then
 *   2.: For each possible Knight move
 *      2.1.: if move is not out of bound and spot is not visited
 *          2.1.1.: return true;
 *      2.2.: if move is not legal
 *          2.2.1.: return false;
 *   3.: No move available
 *      3.1.: return false;
 *
 */

public class Main {
    private static final Point[] MOVES = new Point[]{
            new Point(-2, -1),
            new Point(-1, -2),
            new Point(-2, 1),
            new Point(2, -1),
            new Point(-1, 2),
            new Point(1, -2),
            new Point(1, 2),
            new Point(2, 1)
    };
    static int FREE = -1;

    public static void main(String[] argv) {

        int[][] board;
        int x;
        int y;
        try (Scanner scanner = new Scanner(System.in)) {

            // Reads the size of the chess board.
            System.out.print("Size of board?(n): ");
            board = createBoard(scanner.nextInt());
            System.out.println("Knight start position");
            System.out.print("X: ");
            x = scanner.nextInt();
            System.out.print("Y: ");
            y = scanner.nextInt();
        } catch (InputMismatchException ex) {
            System.out.println(ex.toString());
            System.out.println("Error: Illegal symbol...");
            System.out.println();
            System.out.println("Setting default values: Board: 6, Startposition: 1,1");
            board = createBoard(6);
            x = 1;
            y = 1;
        }

        //If path is found, print out the board.
        if (findPath(x, y, 0, board)) {
            printBoard(board);
        }
        // Path could not be found.
        else {
            System.out.println("Could not find a path");
        }

    }


    public static boolean findPath(int currentX, int currentY, int moveCount, int[][] board) {
        //If amount of moves are equals to boards total spots, return true.
        if (moveCount == board.length * board.length) {
            return true;
        }
        int bSize = board.length;
        int xNew;
        int yNew;
        //For possible Knight move
        for (Point move : MOVES) {
            //Sets the next move
            xNew = move.x + currentX;
            yNew = move.y + currentY;
            //If next spot is not out of bound.
            if ((xNew >= 0) && (xNew < bSize) && (yNew >= 0) && (yNew < bSize)) {
                //if new spot is not visited, set spots number to times moved.
                if (board[xNew][yNew] == -1) {
                    board[xNew][yNew] = moveCount;
                    //If next move is possible, return true.
                    if (findPath(xNew, yNew, moveCount + 1, board)) {
                        return true;
                    }
                    //no path available from this spot. Set current spot as free.
                    board[xNew][yNew] = FREE;// backtracking
                }
            }
        }
        //Path is not good. return false.
        return false;
    }

    static int[][] createBoard(int bSize) {
        int[][] board = new int[bSize][bSize];
        for (int x = 0; x < bSize; x++) {
            for (int y = 0; y < bSize; y++) {
                board[x][y] = FREE;
            }
        }
        return board;
    }

    static void printBoard(@NotNull int[][] board) {
        int bSize = board.length;
        System.out.println();
        for (int i = 0; i < bSize; i++) {
            for (int j = 0; j < bSize; j++) {
                System.out.print(board[i][j] + "\t");
            }
            System.out.println();
        }
    }
}