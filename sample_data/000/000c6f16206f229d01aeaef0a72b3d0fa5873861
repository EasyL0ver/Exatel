if (state.pickup_price) {
                    const cost = state.pickup_price
                    //Добавляем к итоговой сумме
                    total += cost
                    //Добавляем в детали информацию о стоимости посадки
                    details.push({
                        name    : 'Pick up',
                        cost,
                        measure : opts.Order && order && order.pay_type == opts.Order.PayTypes.BONUSES ? 'IБ' : 'RUR',
                        currency: opts.currency ? opts.currency : ''
                    })
                }

                //Если назначена цена ожидания
                if (this.wait_price && (this.wait_free < state.wait)) {
                    //Из времени ожидания посадки (сек) вычитаем бесплатное время ожидания(мин)*60
                    const amount = Math.max(state.wait - this.wait_free * 60, 0) / 60;
                    //Вычисляем стоимость ожидания
                    const cost   = this.constructor.roundCost(state.wait / 60 * this.wait_price)
                    if (cost > 0) {
                        //Добавляем к итоговой сумме
                        total += cost
                        let hours     = state.wait / 3600
                        const seconds = state.wait % 60
                        const minutes = Math.floor((state.wait % 3600) / 60)
                        let amount    = ''
                        if (hours >= 1) {
                            hours = Math.floor(hours)
                            amount += ((hours < 10 ? '0' : '') + hours + ':')
                        }
                        amount += ((minutes < 10 ? '0' : '') + minutes + ':' + (seconds < 10 ? '0' : '') + seconds)

                        //Добавляем в детали информацию об ожидании и стоимость ожидания и время в минутах
                        details.push({
                            name    : 'Wait',
                            cost,
                            amount,
                            measure : (hours < 1 ? 'min' : 'h'),
                            currency: opts.currency || ''
                        })
                    }
                }

                let costWithTime   = 0;
                let tariffWithTime = citySettings && citySettings.taximetr_mode;
                if (tariffWithTime) {
                    let timePricePerMinute = this.time_price / 60;
                    let durationInMinutes  = this.getTimeInMinutes(state.duration / 3600);

                    costWithTime += timePricePerMinute * durationInMinutes;
                }

                //Если стоит галочка расчета по дистанции или расчета по времени + дистанции
                if (this.distance_enabled || tariffWithTime) {
                    total += costWithTime || 0;
                    //Если стоимость минимальной оплаты при оплате по дистанции > 0
                    if (this.distance_min_price) {
                        const cost = this.distance_min_price || 0
                        //Добавляем к итоговой сумме
                        total += cost;


                        //Добавляем к минимальной сумме
                        minimal += cost
                        //Добавляем в детали информацию об остановках
                        //??? Почему в amount идет кол-во бесплатных километров ???
                        details.push({
                            name    : 'Distance (minimal)',
                            cost,
                            amount  : this.distance_free + '',
                            measure : this.distanceMeasure(),
                            currency: opts.currency || ''
                        })
                    }

                    //??? Если точка А в городе ???
                    if (state.start_in) {
                        //Вычитаем кол-во бесплатных километров из пройденного расстояния в городе
                        distance_in -= this.distance_free
                        //Если кол-во бесплатных километров больше пройденного расстояния в городе
                        if (distance_in < 0)
                        //Вычитаем из пройденного расст. за городом кол-во оставшихся бесплатных километров
                            distance_out += distance_in
                    } else {
                        //??? Если точка А за городом ???
                        //Вычитаем бесплатные км из кол-во пройденных км за городом
                        distance_out -= this.distance_free
                        //Если остались бесплатные км
                        if (distance_out < 0)
                        //вычитаем их из пройденного расстояния в городе
                            distance_in += distance_out
                    }

                    //Кастомное округление (1 параметр - значение, фактор(например 0.5), тип округления - например UNIT)
                    distance_in  = this.constructor.roundCustom(distance_in, this.distance_round, this.distance_round_type)
                    distance_out = this.constructor.roundCustom(distance_out, this.distance_round, this.distance_round_type)

                    let start_distance_already_counted = false;
                    if (distance_in > 0) {
                        //Считаем стоимость расстояния пройденного по городу и округляем
                        let cost = this.constructor.roundCost(distance_in * this.distance_in_price);
                        if (cost > 0) {
                            total += cost;
                            details.push({
                                name    : 'Distance',
                                cost,
                                amount  : distance_in + '',
                                measure : this.distanceMeasure(),
                                currency: opts.currency || ''
                            })
                        }
                    }

                    // console.log('[+] distance_out : ', distance_out);
                    //Если пройденная дистанция за городом > 0
                    if (distance_out > 0) {
                        let cost;

                        //Если активна отдельная цена для поездок за городом, используем ее. Иначе - используем цену для города
                        cost = this.constructor.roundCost(distance_out * (this.distance_out_enabled ? this.distance_out_price : this.distance_in_price))
                        if (cost > 0) {
                            total += cost
                            details.push({
                                name    : 'Distance (out of the city)',
                                cost,
                                amount  : distance_out + '',
                                measure : this.distanceMeasure(),
                                currency: opts.currency || ''
                            })
                        }
                    }
                }