#include <iostream>
using namespace std;

//Napomena: U rješenju svaka klasa treba da posjeduje odgovarajući header i cpp file.

#include<iostream>

using namespace std;

class Vrijeme {
	int _sati;
	int _minute;
	int _sekunde;
public:

	bool validnoVrijeme(int sati, int minute, int sekunde)
	{
		return (sati >= 0 && sati < 24) && (minute >= 0 && minute < 60) && (sekunde >= 0 && sekunde < 60);
	}

	int getSati() const
	{
		return _sati;
	}

	int getMinute() const
	{
		return _minute;
	}

	int getSekunde() const
	{
		return _sekunde;
	}

	void setSati(int sati)
	{
		_sati = sati;

	}

	void setMinute(int minute)
	{
			_minute = minute;
	}

	void setSekunde(int sekunde)
	{
			_sekunde = sekunde;
	}
		
	//Konstruktor bez parametara
	Vrijeme()
	{
		_sati = 0;
		_minute = 0;
		_sekunde = 0;
	}
	//Konstruktor sa 3 parametra (sati, minute i sekunde)
	Vrijeme(int sati, int minute, int sekunde)
	{
		if (validnoVrijeme(sati, minute, sekunde))
		{
			_sati = sati;
			_minute = minute;
			_sekunde = sekunde;
		}
		else
			cout << "Neispravan unos!" << endl;
	}
	//Konstruktor sa 2 parametra (sati i minute)
	Vrijeme(int sati, int minute)
	{
		if (validnoVrijeme(sati, minute, 0))
		{
			_sati = sati;
			_minute = minute;
			_sekunde = 0;
		}
	}

	Vrijeme(int minute)
	{
		_minute = minute;
	}
	//Funkciju Info sa neobaveznim parametrom tipa bool koji određuje da li će vrijeme biti ispisano u punom formatu
	//(hh:mm:ss) ili u skraćenom formatu (hh:mm). Default-no funkcija vrši ispis u punom formatu.
	void info(bool format = true)
	{
		if (format)
			cout << _sati << ":" << _minute << ":" << _sekunde << endl;
		else
			cout << _sati << ":" << _minute << endl;
	}
	
	void infoMinute()
	{
		cout << _minute << endl;
	}
	//Funkciju Add koja kao rezultat vraća novi objekat tipa vrijeme koji predstavlja 
	//sumu vremena poslijeđenog kao parametar i instance this.
	Vrijeme Add(Vrijeme v1)
	{
		Vrijeme novi;
		novi.setSekunde(this->getSekunde() + v1.getSekunde());
		novi.setMinute(this->getMinute() + v1.getMinute());
		novi.setSati(this->getSati() + v1.getSati());
		
		if (novi.getSekunde() % 60 == 0)
		{
			novi.setMinute(novi.getMinute() + (novi.getSekunde() / 60));
			novi.setSekunde(0);
		}

		if (novi.getMinute() % 60 == 0)
		{
			novi.setSati(novi.getSati() + (novi.getMinute() / 60));
			novi.setMinute(0);
		}
		if (novi.getSekunde() % 60 != 0)
		{
			novi.setMinute(novi.getMinute() + (novi.getSekunde() / 60));
			novi.setSekunde(novi.getSekunde() % 60);
		}

		if (novi.getMinute() % 60 != 0)
		{
			novi.setSati(novi.getSati() + (novi.getMinute() / 60));
			novi.setMinute(novi.getMinute() % 60);
		}
		return Vrijeme(novi.getSati(),novi.getMinute(),novi.getSekunde());
	}

	//Funkciju Add koja kao rezultat vraća novi objekat tipa vrijeme koji predstavlja 
	//sumu parametra izraženog u minutama i vremena instance this.
	Vrijeme AddMinute(Vrijeme v1)
	{
		Vrijeme novi;
		novi.setSekunde(this->getSekunde() + v1.getSekunde());
		novi.setMinute(this->getMinute() + v1.getMinute());
		novi.setSati(this->getSati() + v1.getSati());

		if (novi.getSekunde() % 60 == 0)
		{
			novi.setMinute(novi.getMinute() + (novi.getSekunde() / 60));
			novi.setSekunde(0);
		}

		if (novi.getMinute() % 60 == 0)
		{
			novi.setSati(novi.getSati() + (novi.getMinute() / 60));
			novi.setMinute(0);
		}
		if (novi.getSekunde() % 60 != 0)
		{
			novi.setMinute(novi.getMinute() + (novi.getSekunde() / 60));
			novi.setSekunde(novi.getSekunde() % 60);
		}

		if (novi.getMinute() % 60 != 0)
		{
			novi.setSati(novi.getSati() + (novi.getMinute() / 60));
			novi.setMinute(novi.getMinute() % 60);
		}
		

		novi.setMinute(novi.getSati() * 60 + novi.getMinute());

		return Vrijeme(novi.getMinute());
	}

	//Funkciju CompareTo koja vraća vrijednost tipa int u zavisnosti od toga da li je vrijeme instance this prije, 
	//jednako ili poslije
	//vremena proslijeđenog kao parametar.
	//Moguće povratne vrijednosti:
	//-1 - vrijeme instance this nastupa prije vremena v2
	// 0 - vrijeme instance this je jednako vremenu v2
	// 1 - vrijeme instance this nastupa nakon vremena v2
	int CompareTo(Vrijeme v1)
	{
		int sekunde1 = 0, sekunde2 = 0;

		sekunde1 = this->getSati() * 3600 + this->getMinute() * 60 + this->getSekunde();
		sekunde2 = v1.getSati() * 3600 + v1.getMinute() * 60 + v1.getSekunde();

		if (sekunde1 < sekunde2)
			return -1;
		else if (sekunde1 == sekunde2)
			return 0;
		else
			return 1;
	}

};


/*
Potrebno je kreirati aplikaciju za dijeljenje znanja putem razmjene članaka među korisnicima.

Izdvojene su sljedeće funkcionalnosti:
- Administrator sistema je zadužen za upravljanje korisničkim nalozima (Ime, Prezime, Email, DatumRegistracije, 
KorisnickoIme, Lozinka).
- Svaki članak (Naslov, Sadrzaj, Datum, Satnica, BrojPregleda) može sadržavati više tagova, ali pripada samo jednoj 
oblasti.
- Članke mogu dodavati svi registrovani korisnici.
- Korisnici aplikacije također mogu ostaviti komentar (Tekst, Datum, Popularnost) na određeni članak.
*/

/*
Na osnovu datih klasa implementirati opisane funkcionalnosti sistema. Po potrebi dopuniti klase novim atributima 
i/ili funkcijama.
*/

class Datum
{
	int _dan;
	int _mjesec;
	int _godina;
public:
	//Potrebne konstruktor i destruktor funkcije
	Datum()
	{
		_dan = _mjesec = _godina = 0;
	}

	Datum(int dan, int mjesec, int godina)
	{
		if (ValidanDatum(dan, mjesec, godina))
		{
			_dan = dan;
			_mjesec = mjesec;
			_godina = godina;
		}
		else
		{
			_dan = _mjesec = 1;
			_godina = 2000;
		}
	}
	//Funkciju Info

	void Info()
	{
		cout << _dan << "." << _mjesec << "." << _godina << endl;
	}

	void setDan(int dan)
	{
		if(ValidanDatum(dan, _mjesec, _godina))
		_dan = dan;
	}

	void setMjesec(int mjesec)
	{
		if (ValidanDatum(_dan, mjesec, _godina))
		_mjesec = mjesec;
	}

	void setGodina(int godina) 
	{
		if (ValidanDatum(_dan, _mjesec, godina))
		_godina = godina;
	}

	int getDan() const
	{
		return _dan;
	}

	int getMjesec() const
	{
		return _mjesec;
	}

	int getGodina() const
	{
		return _godina;
	}

	bool ValidanDatum(int dan, int mjesec, int godina)
	{
		if (dan > 0 && dan <= getPosljednjiDanUMjesecu(mjesec, godina) && mjesec > 0 && mjesec <= 12)
			return true;
		return false;
	}

	int getPosljednjiDanUMjesecu(int mjesec, int godina)
	{
		if (mjesec == 4 || mjesec == 6 || mjesec == 9 || mjesec == 11)
			return 30;
		if (mjesec == 2)
			return 28 + prestupnaGodina(godina);
		return 31;
	}

	int prestupnaGodina(int godina)
	{
		if (godina % 4 == 0 && godina%100!=0 || godina%400==0)
			return 1;
		return 0;
	}

	void dodajDane(int dani)
	{
		if (ValidanDatum(_dan + dani, _mjesec, _godina))
		{
			_dan += dani;
			return;
		}
		int razlika = 0;
		while (dani > 0)
		{
			razlika = getPosljednjiDanUMjesecu(_mjesec, _godina) - _dan + 1;

			if (razlika < dani)
			{
				dani -= razlika;
				_dan = 1;
				_mjesec++;

				if (_mjesec > 12)
				{
					_mjesec = 1;
					_godina++;
				}
			}
			else
			{
				_dan += dani;
				dani = 0;
			}
		}
	}
};

class Korisnik
{
	char _ime[30];
	char _korisnickoIme[20];
	char* _lozinka;
	char _tipKorisnika[30]; //Administrator, Guest
public:

	const char *getTipKorisnika()
	{
		return _tipKorisnika;
	}

	const char *getIme()
	{
		return _ime;
	}

	void KorisnickoIme()
	{
		cout << _korisnickoIme << endl;
	}
	//Potrebne konstruktor i destruktor funkcije
	Korisnik()
	{
		strcpy_s(_ime, "Unknown");
		strcpy_s(_korisnickoIme, "Unknown");
		_lozinka = new char[strlen("---") + 1];
		strcpy_s(_lozinka, strlen("---") + 1, "---");
		strcpy_s(_tipKorisnika,"---");
	}

	Korisnik(const char ime[], const char korisnickoIme[], const char *lozinka, const char tipKorisnika[])
	{
		strncpy_s(_ime, ime,30);
		strncpy_s(_korisnickoIme, korisnickoIme,30);
		_lozinka = new char[strlen(lozinka) + 1];
		strcpy_s(_lozinka, strlen(lozinka) + 1, lozinka);
		strncpy_s(_tipKorisnika, tipKorisnika, 30);
	}
	~Korisnik()
	{
		if (_lozinka != nullptr)
			delete[] _lozinka;
		_lozinka = nullptr;
	}
	Korisnik(Korisnik &korisnik)
	{
		strncpy_s(_ime, korisnik._ime,30);
		strncpy_s(_korisnickoIme, korisnik._korisnickoIme,30);
		if (_lozinka != nullptr)
		{
			delete[] _lozinka;
			_lozinka = new char[strlen(korisnik._lozinka) + 1];
			strcpy_s(_lozinka, strlen(korisnik._lozinka) + 1, korisnik._lozinka);
		}
		strncpy_s(_tipKorisnika, korisnik._tipKorisnika,30);
	}

	//Funkciju za promjenu korisničke lozinke
	void promijeniSifru(const char *novaSifra)
	{
		if (_lozinka != nullptr)
			delete[] _lozinka;
		_lozinka = new char[strlen(novaSifra) + 1];
		strcpy_s(_lozinka, strlen(novaSifra) + 1, novaSifra);
	}
	//Funkciju Info

	void Info()
	{
		cout << "Ime: " << _ime << endl;
		cout << "Korisnicko ime: "<<_korisnickoIme << endl;
		if (_lozinka != nullptr)
			cout << "Lozinka: " << _lozinka<<endl;
		cout << "Tip korisnika: " << _tipKorisnika << endl;
	}

	bool istoKorisnickoIme(Korisnik korisnik)
	{
		if (strcmp(_korisnickoIme, korisnik._korisnickoIme) == 0)
			return true;
		return false;
	}
};

class Komentar
{
	char* _tekst;
	Datum _datum;
	Vrijeme _satnica;
	int _popularnost;
	Korisnik* _autor;
public:
	//Potrebne konstruktor i destruktor funkcije
	Komentar()
	{
		_tekst = new char[strlen("---") + 1];
		strcpy_s(_tekst, strlen("---") + 1, "---");
		_popularnost = 0;
		_autor = nullptr;
	}

	~Komentar()
	{
		if (_tekst != nullptr)
			delete[] _tekst;
		_tekst = nullptr;
	}

	Komentar(const char *tekst, Datum datum, Vrijeme satnica, int popularnost, Korisnik &autor)
	{
		_tekst = new char[strlen(tekst) + 1];
		strcpy_s(_tekst, strlen(tekst) + 1, tekst);
		_datum = datum;
		_satnica =