package SyncroBid::DB::Schema::Result::Company;

use warnings;
use strict;

use DateTime;
use Digest::HMAC_SHA1;
use String::Urandom;
use Data::Dumper;

use base qw/DBIx::Class::Core/;

__PACKAGE__->load_components(qw/InflateColumn::DateTime TimeStamp/);
__PACKAGE__->table( 'company' );
__PACKAGE__->add_columns(
	id => {
		data_type => 'integer',
		is_auto_increment => 1, },
	name => {
		data_type => 'text',
		is_nullable => 0 },
	username => {
		data_type => 'text',
		is_nullable => 0 },
	type => {
		data_type => 'text',
		is_nullable => 0 },
	tier => {
		data_type => 'text',
		is_nullable => 0,
		default_value => 'free' },
	subscription_id => {
		data_type => 'text',
		is_nullable => 1 },
	status => {
		data_type => 'text',
		is_nullable => 0,
		default_value => 'pending' },
	last_access => {
		data_type => 'datetime',
		is_nullable => 0,
		set_on_create => 1, },
	timestamp => {
		data_type => 'datetime',
		is_nullable => 0,
		set_on_create => 1, }
);

__PACKAGE__->set_primary_key( qw/id/ );
__PACKAGE__->add_unique_constraint([ qw/username/ ]);

sub new {
	my ( $class, $args ) = ( shift, shift );

  # Generate authentication token
  my $hash = Digest::HMAC_SHA1->new;

  $hash->add( $args->{username} );

  my $urandom = String::Urandom->new(
    LENGTH => 20, 
    CHARS => [ "A" .. "Z", "a" .. "z", 0 .. 9 ] 
  );  

  $hash->add( $urandom->rand_string );

	push( @{ $args->{metadata} }, { key => 'auth_token', value => $hash->hexdigest } );

	my @allowed_args = ( __PACKAGE__->columns, __PACKAGE__->relationships );

	# Only allow data which is a column or a relationship
	my $return_args = { map { $_ => $args->{$_} } grep( exists $args->{$_}, @allowed_args ) };

	# We must pass the source and handle back
	for ( qw/-result_source -source_handle/ ) {
		$return_args->{$_} = $args->{$_};
	}

	return $class->next::method( $return_args );
}

sub touch {
	my ( $self ) = @_;

	$self->last_access( DateTime->now() );

	$self->update();
}

sub owners {
	my ( $self ) = @_;

	my @owner_ids = $self->metadata->search({ key => 'owner' })->get_column( 'value' )->all;

	warn Dumper( @owner_ids );

	return $self->employees->search({ id => \@owner_ids });
}

sub employees {
	my ( $self ) = @_;

	return $self->offices->search_related( 'employees' );
}

# Relationships

__PACKAGE__->has_many(
	'offices' => 'SyncroBid::DB::Schema::Result::Office',
	{ 'foreign.company_id' => 'self.id' }
);

__PACKAGE__->has_many(
	'metadata' => 'SyncroBid::DB::Schema::Result::CompanyMetadata',
	{ 'foreign.company_id' => 'self.id' }
);

1;