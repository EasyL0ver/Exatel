mod sieve {
    #[derive(Debug, Copy, Clone, Eq, PartialEq)]
    enum IsPrime {
        Prime,
        NotPrime,
    }
    
    #[derive(Debug, Copy, Clone)]
    enum SieveState {
        Running(usize),
        Finished,
    }
    
    #[derive(Debug, Clone)]
    pub struct Sieve {
        sieve: Vec<IsPrime>,
        state: SieveState,
    }
    
    impl Sieve {
        pub fn new(len: usize) -> Sieve {
            assert!(len > 2);
    
            Sieve {
                sieve: vec![IsPrime::Prime; len],
                state: SieveState::Running(2)
            }
        }
    }
    
    impl Iterator for Sieve {
        type Item = usize;
    
        fn next(&mut self) -> Option<Self::Item> {
            use std::iter::repeat;
            use self::IsPrime::*;
            use self::SieveState::*;
    
            match self.state {
                Finished => None,
                Running(cur) => {
                    let len = self.sieve.len();
                    
                    // Mark all multiples of the current value.
                    repeat(cur)
                        .zip(cur..)
                        .map(|(a,b)| a*b)
                        .take_while(|&i| i < len)
                        .for_each(|i| self.sieve[i] = NotPrime);
    
                    // Find the next prime number.
                    let next = self.sieve.iter()
                        .enumerate()
                        .skip(cur+1)
                        .skip_while(|&(_,&p)| p == NotPrime)
                        .next();
    
                    match next {
                        None => {
                            self.state = Finished;
                            return Some(cur);
                        },
                        Some((i,_)) => {
                            self.state = Running(i);
                            return Some(cur);
                        }
                    }
                }
            }
        }
    }
}
use sieve::*;

fn main() {
    for p in Sieve::new(1_000_000).take(25) {
        print!("{}, ", p);
    }
}