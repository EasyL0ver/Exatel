//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by Fernflower decompiler)
//

package pro.foundev.solr;

import com.datastax.driver.core.BoundStatement;
import com.datastax.driver.core.Cluster;
import com.datastax.driver.core.PreparedStatement;
import com.datastax.driver.core.ResultSetFuture;
import com.datastax.driver.core.Session;
import com.github.javafaker.Faker;
import com.google.common.base.Stopwatch;
import com.google.common.base.Strings;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;
import java.util.Date;
import java.util.List;
import java.util.Random;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;

public class App {
    public App() {
    }

    public static void main(String[] args) {
        Runnable usage = () -> {
            System.out.println("usage: java -jar solr_class_ingest.jar <num record> <threads>");
            System.out.println("  - <num record> can be 1M for 1 million or 1000000");
            System.out.println("    supported suffixes are M or m for million, B or b for billion, and K or k for thousands");
            System.out.println("  - <threads> optional default of 2");
        };
        if (args.length == 0) {
            usage.run();
        } else {
            Consumer<Long> exec = (countx) -> {
                Cluster cluster = Cluster.builder().addContactPoint("localhost").build();
                Throwable var3 = null;

                try {
                    Session session = cluster.newSession();
                    Throwable var5 = null;

                    try {
                        Faker faker = new Faker();
                        Random random = new Random();
                        PreparedStatement statement = session.prepare("INSERT INTO killrvideo.videos ( videoid,    added_date,    description,    location,    location_type,    name,    preview_image_location,    tags,    userid)    values (?, ?, ?, ?, ?, ?, ?, ?, ?)");
                        long futuresInFlight = 2L;
                        if (args.length > 1) {
                            futuresInFlight = Long.parseLong(args[1]);
                        }

                        long iterations = countx / futuresInFlight;
                        Stopwatch stopwatch = new Stopwatch();
                        stopwatch.start();

                        for(int i = 0; (long)i < iterations; ++i) {
                            if (i != 0 && i % 10000 == 0) {
                                long durationx = stopwatch.elapsed(TimeUnit.SECONDS);
                                System.out.println(i + 1 + " records ingested at " + durationx + " seconds. TPS of " + countx / durationx);
                            }

                            List<ResultSetFuture> futures = Lists.newArrayList();

                            for(int j = 0; (long)j < futuresInFlight; ++j) {
                                UUID videoId = UUID.randomUUID();
                                Date addedDate = faker.date().past(365, TimeUnit.DAYS);
                                String description = faker.lorem().paragraph();
                                String location = faker.country().iso();
                                Integer location_type = random.nextInt(10);
                                String name = faker.company().name();
                                String preview_image_location = faker.internet().avatar();
                                Set<String> tags = Sets.newHashSet(new String[]{faker.company().name(), faker.company().name()});
                                UUID userId = UUID.randomUUID();
                                BoundStatement boundStatement = statement.bind(new Object[]{videoId, addedDate, description, location, location_type, name, preview_image_location, tags, userId});
                                futures.add(session.executeAsync(boundStatement));
                            }

                            futures.forEach(ResultSetFuture::getUninterruptibly);
                        }

                        long duration = stopwatch.elapsed(TimeUnit.SECONDS);
                        System.out.println("Completed " + countx + " records in " + duration + " seconds. TPS " + countx / duration);
                        stopwatch.stop();
                    } catch (Throwable var48) {
                        var5 = var48;
                        throw var48;
                    } finally {
                        if (session != null) {
                            if (var5 != null) {
                                try {
                                    session.close();
                                } catch (Throwable var47) {
                                    var5.addSuppressed(var47);
                                }
                            } else {
                                session.close();
                            }
                        }

                    }
                } catch (Throwable var50) {
                    var3 = var50;
                    throw var50;
                } finally {
                    if (cluster != null) {
                        if (var3 != null) {
                            try {
                                cluster.close();
                            } catch (Throwable var46) {
                                var3.addSuppressed(var46);
                            }
                        } else {
                            cluster.close();
                        }
                    }

                }
            };
            String numRecordsString = args[0];
            if (Strings.isNullOrEmpty(numRecordsString.trim())) {
                usage.run();
                return;
            }

            int length = numRecordsString.length();
            StringBuilder numberPortion = new StringBuilder();

            for(int i = 0; i < length; ++i) {
                if (i == length - 1) {
                    char lastCharacter = numRecordsString.charAt(i);
                    long count;
                    if (lastCharacter != 'M' && lastCharacter != 'm') {
                        if (lastCharacter != 'B' && lastCharacter != 'b') {
                            if (lastCharacter != 'K' && lastCharacter != 'k') {
                                count = Long.parseLong(numRecordsString);
                            } else {
                                count = Long.parseLong(numberPortion.toString()) * 1000L;
                            }
                        } else {
                            count = Long.parseLong(numberPortion.toString()) * 1000000000L;
                        }
                    } else {
                        count = Long.parseLong(numberPortion.toString()) * 1000000L;
                    }

                    exec.accept(count);
                    return;
                }

                numberPortion.append(numRecordsString.charAt(i));
            }
        }

    }
}