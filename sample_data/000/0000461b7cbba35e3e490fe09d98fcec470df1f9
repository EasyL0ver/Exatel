def __recursive_dict_compare_dispatch(self, dict_data, dict_conf, **kwargs):
        # get dispatchers from kwargs // do not pop them out, we need them to recurse
        isinstance_dispatch = kwargs.get('isinstance_dispatch')
        issubclass_dispatch = kwargs.get('issubclass_dispatch')
        no_handle_dispatch = kwargs.get('no_handle_dispatch')
        raise_no_dispatch = kwargs.get('raise_no_dispatch', True)
        # loop over all the keys in this layer of the defaults
        for conf_key, conf_value in dict_conf.items():
            # we should only enter one of these conditions
            # check for isinstance condition and dispatch
            if isinstance_dispatch is not None and \
                    isinstance(conf_value, tuple(isinstance_dispatch.keys())) and \
                    type(conf_value) in isinstance_dispatch.keys():
                # get dispatcher
                dispatcher = isinstance_dispatch[type(conf_value)]
                # dispatch
                dispatcher(dict_data, dict_conf, **kwargs)
            # check for issubclass condition and dispatch
            elif issubclass_dispatch is not None and \
                    isinstance(conf_value, types.ClassType) and \
                    issubclass(conf_value, tuple(issubclass_dispatch.keys())) and \
                    conf_value in issubclass_dispatch.keys():
                # get dispatcher
                dispatcher = issubclass_dispatch[conf_value]
                # dispatch
                dispatcher(dict_data, dict_conf, **kwargs)
            elif no_handle_dispatch is not None:
                no_handle_dispatch(dict_data, dict_conf, **kwargs)
            elif raise_no_dispatch:
                raise RuntimeError('no dispatch for: key={} value={}'.format(conf_key, conf_value))
        # returns the json_data
        return dict_data