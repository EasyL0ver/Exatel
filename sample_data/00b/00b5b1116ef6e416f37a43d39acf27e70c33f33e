#include <iostream>
#include <iomanip>
#include <algorithm>
#include <random>
#include <chrono>
#include <cstdlib>
#include <cassert>

#ifdef __AVX__
    #include <immintrin.h>
#endif

void vectorCopy(double *dst, const double *src, const int n) {
    #ifdef __AVX__
        const int bytesToAlignment = int((uint64_t(dst) + 31)/ 32 * 32 - uint64_t(dst));
        const int vectorPartBegin  = std::min(n, bytesToAlignment / 8);
        const int vectorPartEnd    = vectorPartBegin + (n - vectorPartBegin) / 4 * 4;
        for (int i = 0; i < vectorPartBegin; ++i) {
            dst[i] = src[i];
        }
        for (int i = vectorPartBegin; i < vectorPartEnd; i += 4) {
            _mm256_storeu_pd(dst+i, _mm256_loadu_pd(src+i));
        }
        for (int i = vectorPartEnd; i < n; ++i) {
            dst[i] = src[i];
        }
    #else
        for (int i = 0; i < n; ++i) {
            dst[i] = src[i];
        }
    #endif
}

double vectorDotProduct(const double *x, const double *y, const int n) {
    #ifdef __AVX__
        const int bytesToAlignment = int((uint64_t(x) + 31)/ 32 * 32 - uint64_t(x));
        const int vectorPartBegin  = std::min(n, bytesToAlignment / 8);
        const int vectorPartEnd    = vectorPartBegin + (n - vectorPartBegin) / 4 * 4;
        double res = 0;
        for (int i = 0; i < vectorPartBegin; ++i) {
            res += x[i] * y[i];
        }
        auto temp = _mm256_setzero_pd();
        for (int i = vectorPartBegin; i < vectorPartEnd; i += 4) {
            const auto vx = _mm256_loadu_pd(x+i);
            const auto vy = _mm256_loadu_pd(y+i);
            temp = _mm256_add_pd(temp, _mm256_mul_pd(vx,vy));
        }
        double work[4];
        _mm256_storeu_pd(work, temp);
        res += work[0] + work[1] + work[2] + work[3];
        for (int i = vectorPartEnd; i < n; ++i) {
            res += x[i] * y[i];
        }
        return res;
    #else
        double res = 0;
        for (int i = 0; i < n; ++i) {
            res += x[i] * y[i];
        }
        return res;
    #endif
}

struct Matrix {
    
    int nRows, nCols;
    
    double **data;
    
    void Alloc() {
        data = (double**)std::malloc(sizeof(double*) * nRows);
        for (int row = 0; row < nRows; ++row) {
            #ifdef __AVX__
                data[row] = (double*)_mm_malloc(sizeof(double) * nCols, 32);
            #else
                data[row] = (double*)std::malloc(sizeof(double) * nCols);
            #endif
        }
    }
    
    void Clean() {
        if (data == 0) return;
        for (int row = 0; row < nRows; ++row) {
            if (data[row] == 0) continue;
            #ifdef __AVX__
                _mm_free(data[row]);
            #else
                std::free(data[row]);
            #endif
            data[row] = 0;
        }
        std::free(data);
        data = 0;
    }
    
    Matrix(int nRows_, int nCols_) : nRows(nRows_), nCols(nCols_), data(0) { Alloc(); }
    
    ~Matrix() { Clean(); }
    
    double& operator()(int row, int col) { return data[row][col]; }
    
    const double& operator()(int row, int col) const { return data[row][col]; }
    
    Matrix& operator=(const Matrix &other) {
        Clean();
        nRows = other.nRows, nCols = other.nCols;
        Alloc();
        for (int row = 0; row < nRows; ++row) {
            vectorCopy(data[row], other.data[row], nCols);
        }
        return *this;
    }
    
    Matrix(const Matrix& other) : nRows(other.nRows), nCols(other.nCols) {
        Alloc();
        for (int row = 0; row < nRows; ++row) {
            vectorCopy(data[row], other.data[row], nCols);
        }
    }
    
    Matrix& Transpose() {
        Matrix temp(nCols, nRows);
        for (int row = 0; row < nRows; ++row) {
            for (int col = 0; col < nCols; ++col) {
                temp(col,row) = (*this)(row,col);
            }
        }
        return *this = temp;
    }
};


Matrix mult(Matrix &lhs, Matrix &rhs) {
    //std::cout << "mult begin" << std::endl;
    rhs.Transpose();
    Matrix res(lhs.nRows, rhs.nRows);
    for (int row = 0; row < res.nRows; ++row) {
        for (int col = 0; col < res.nCols; ++col) {
            res(row,col) = vectorDotProduct(lhs.data[row], rhs.data[col], lhs.nCols);
        }
    }
    rhs.Transpose();
    //std::cout << "mult end" << std::endl;
    return res;
}



int main() {
    std::cout << std::fixed << std::setprecision(3);
    // Generate matrices
    std::mt19937 gen;
    std::uniform_real_distribution<double> dist(0,1);
    const int N = 2000;
    {
        Matrix A(N, N), B(N, N);
        for (int i = 0; i < N; ++i) {
            for (int j = 0; j < N; ++j) {
                A(i,j) = dist(gen);
                B(i,j) = dist(gen);
            }
        }
        // Multiply matrices:
        double ts = (double)clock();
        Matrix C = mult(A,B);
        double tf = (double)clock();
        double res = 0;
        for (int row = 0; row < N; ++row) {
            for (int col = 0; col < N; ++col) {
                res += C(row,col);
            }
        }
        double time = (tf - ts) / CLOCKS_PER_SEC;
        std::cout << "finished with runtime = " << std::setw(6) << time << "s, checksum = " << res << std::endl;
    }
    return 0;
}