package project;


import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;

import project.graph.EuclidianEdge;
import project.graph.EuclidianVertex;
import project.graph.Graph;
import project.graph.Edge;

public class Dijkstra<V extends EuclidianVertex, E extends EuclidianEdge<V>> {

	public List<E> perform(Graph<V, E> graph, V start, V end) {

		/*01*/HashMap<V, Double> dist = new HashMap<V, Double>();
		/*02*/HashMap<V, V> pred = new HashMap<V, V>();
		/*03*/HashSet<V> vCopy = new HashSet<V>(graph.vertices());
		
		/*04*//* Initialisierung. */
		/*05*/	for (V u : graph.vertices()) {
		/*06*/		dist.put(u, Double.POSITIVE_INFINITY);
		/*07*/		pred.put(u, null);
		/*08*/	}

		//dist.put(start, 0.0);

		/*09*//* Hier beginnt der eigentliche Algorithmus. */
		/*10*/	while (vCopy.size() > 0) {
		/*11*/		//??
		/*12*/		V u = null;
		/*13*/		if(u == end){
		/*14*/			break;
		/*15*/		}
		/*16*/		for (V v : vCopy){
//			FÜR HIER OBEN: (Zeile 16)
//			sammel dir mit Hilfe der Methode neighbors in der Klasse Graph 
//			alle Nachbarn von u. Dann kannst du diese Menge durch die Methode 
//			intersect in SetTools mit der Menge vCopy "schneiden". dann hast du 
//			genau die gesuchte Menge (alle Nachbarn von u die bisher noch nicht 
//			besucht wurden
		/*17*/			/* Distanz und Vorgänger aktualisieren. */
		/*18*/			if(dist.get(u) + d(u,v) < dist.get(v)){
		/*19*/				dist.put(v, dist.get(u) + d(u,v));
		/*20*/				pred.put(v,u);
		/*21*/			}
		/*22*/		}
		/*23*/	}
		/*24*//* Pfadrückverfolgung. */
		/*25*/	LinkedList<E> p = new LinkedList<E>();
		/*26*/	V u = end;
		/*27*/	while(pred.get(u) != null){
		/*28*/		p.addFirst((E)new EuclidianEdge<V>(pred.get(u), u));
		/*29*/		u = pred.get(u);
		/*30*/	}
		/*31*/ 	return p;
	}

	////Zusatzmethode
	private double d(V u, V v) {
		return Math.sqrt(Math.pow(v.x() - u.x(), 2)	+ Math.pow(v.y() - u.y(), 2));
	}

}