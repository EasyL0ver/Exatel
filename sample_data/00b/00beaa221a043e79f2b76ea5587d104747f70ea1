# Auto-generated code below aims at helping you parse
# the standard input according to the problem statement.
def value_of_letter(h, e)
    key=""
    h.each{|k,v|
        if v.include? e
          key=k
         end
    }
    key;
end

def taille_mot(h, mot)
    s=0
    mot.chars.map{|i|s+=value_of_letter(h,i)}
    s;
end

#Needs to be change to verify if there is enough or more letters
def letters_contains_mot(lettersO, mot, motO)
#Mot:String
#Letters:String
letters=lettersO.dup
#Le mot contient toutes les lettres si lettres.length==0
STDERR.puts "Mot Actuel: #{mot.join}"
STDERR.puts "Lettres: #{lettersO.join}"

    if mot.length==0
        return motO
    elsif letters.length==0
        return false
    elsif letters.include? mot[0]
          letters.delete_at(letters.index(mot.shift))
          letters_contains_mot(letters, mot, motO)
    end
end

def best_anagram(tab_mot, letters)
    tab_f=[]
    tab_mot.each{|m,value,i|
        STDERR.puts ""
        STDERR.puts "-- Mot testé: #{m} --"
        STDERR.puts ""
        tab_f << [m,value,i] if letters_contains_mot(letters, m.chars, m)
    }
    STDERR.puts ""
    tab_f=tab_f.sort_by{|w,s,o| s}.reverse
    STDERR.puts "Tableau de résultat: #{tab_f}"
    highest_value=tab_f[0][1]
    tab_tmp=[]
    tab_f.map{|k,v,o|
    tab_tmp << [k,o] if v==highest_value
    break unless v==highest_value}
    tab_tmp.sort_by!(&:last)
    STDERR.puts "Tableau of highest values #{tab_tmp.to_s}"
    tab_tmp[0][0];
end

#### MAIN PROGRAM ###
    
    #Letters sorted by priority in HashMap
    h={}
    h[1]=['e','a','i','o','n','r','t','l','s','u']
    h[2]=['d','g']
    h[3]=['b','c','m','p']
    h[4]=['f','h','v','w','y']
    h[5]=['k']
    h[8]=['j','x']
    h[10]=['q','z']
    
    @n = gets.to_i #Numbers of words in dictionnary
    tmp=[]          #Dictionnary
    @n.times do |i|
        w = gets.chomp
        tmp << [w,taille_mot(h,w), i] #
    end
    @letters = gets.chomp
    
    puts best_anagram(tmp, @letters.chars)
    
###################