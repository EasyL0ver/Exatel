// Wave_Algoritm.cpp
//

/* Задача:

Задан двумерный динамический массив, заполненный случайно 0 и 1. Данный массив представляет собой лабиринт, где 0 - клетки, по которым можно 
передвигаться, 1 - препятствия. Необходимо реализовать волновой алгоритм над данным массивом, т.е. найти кратчайший путь от 
точки старта до точки финиша. Начальную и конечные точки можно задать в коде, необходимо вывести найденный путь.

   Пояснение:

В данном коде выводится начальный массив-лабиринт. После этого в зависимости от заданных начальной и конечной точек следует сообщение
и итоговый массив.

1. Начальная и конечная точка стоят на позиции 0, и между ними существует путь:
        
		Выводится сообщение "Process complete!!!", после чего следует массив, где стартовая точка обозначена цифрой 2, финишная точка - цифрой 3,
		а путь между ними помечен восьмёрками. Препятствия также обозначены цифрой 1, а непройденные поля - цифрой 0.

2. Начальная и конечная точка стоят на позиции 0, но между ними не существует пути:
        
		Выводится сообщение "No way to finish :(" и массив с проставленными точками старта и финиша (старт - 2, финиш - 3).

3. Начальная или конечная точка стоит на позиции 1:

        Выводится сообщение "Start or finish point is in the wall". Необходимо поменять точки старта и финиша, т.е. поставить их на позицию 0.

4. Начальная и конечная точка стоят на позиции 0 и совпадают:

        Выводится сообщение "Start is a finish" и массив с проставленной точкой старт-финиш, помеченной цифрой 3.

Программа может искать путь двумя способами: 

      а). С использованием всей окрестности каждой ячейки (по горизонтали, вертикали и диагоналям)
	  Для реализации данного алгоритма присвойте type_space значение 0.

	  б). С использованием только окрестности по вертикали и горизонтали
	  Для реализации данного алгоритма присвойте type_space любое значение, отличное от 0.
*/



#include "stdafx.h"
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

//Задать тип прохождения пути
const int type_space = 0;

//Задать размеры поля
const int N = 10;    
const int M = 10;

//Задать координаты старта
const int start_X = 6;   
const int start_Y = 2;

//Задать координаты финиша
const int finish_X = 9;   
const int finish_Y = 7;

//Инициализация массива-поля, где 0 - проходимый участок, 1 - препятствие
void init_dynamic(int* A[], int N, int M)
{
	for (int i = 0; i < N; i++)
	{
		for (int j = 0; j < M; j++)
		{
			A[i][j] = rand() % 2;
		}
	}

	return;
}

//Копия массива, над которой и осуществляются дальнейшие операции
void copy_dynamic(int* A[], int* B[], int N, int M)
{
	for (int i = 0; i < N; i++)
	{
		for (int j = 0; j < M; j++)
		{
			B[i][j] = A[i][j];
			if ((A[start_X][start_Y] != 1) && (A[finish_X][finish_Y] != 1))
			{
				A[start_X][start_Y] = 2;
				A[finish_X][finish_Y] = 3;
			}
		}
	}
	return;
}

//Печать массива
void print_dynamic(int* A[], int N, int M)
{
		for (int i = 0; i < N; i++)
		{
			for (int j = 0; j < M; j++)
			{
				printf("%4d", A[i][j]);
			}
			printf("\n");
		}
		return;
}

//Функция-проверка на непринадлежность точки старта или финиша позиции 1
int check_start_finish_point(int* A[], int N, int M)
{
	int res;
	if ((A[start_X][start_Y] != 1) && (A[finish_X][finish_Y] != 1))
		res = 1;
	else
		res = 0;
	return res;
}

//Заполнение границ вокруг ячейки числами по возрастанию.
void set_neib(int* B[], int i, int j, int N, int M, int cheсk)
{

	if (type_space == 0)
	{
		if ((i - 1 >= 0) && (j + 1 < M))
		{
			if (B[i - 1][j + 1] == 0)
				B[i - 1][j + 1] = cheсk;
		}
		if ((j + 1 < M) && (i + 1 < N))
		{
			if (B[i + 1][j + 1] == 0)
				B[i + 1][j + 1] = cheсk;
		}
		if ((i + 1 < N) && (j - 1 >= 0))
		{
			if (B[i + 1][j - 1] == 0)
				B[i + 1][j - 1] = cheсk;
		}
		if ((i - 1 >= 0) && (j - 1 >= 0))
		{
			if (B[i - 1][j - 1] == 0)
				B[i - 1][j - 1] = cheсk;
		}
	}
		if (i + 1 < N)
		{
			if (B[i + 1][j] == 0)
				B[i + 1][j] = cheсk;
		}
		if (i - 1 >= 0)
		{
			if (B[i - 1][j] == 0)
				B[i - 1][j] = cheсk;
		}
		if (j + 1 < M)
		{
			if (B[i][j + 1] == 0)
				B[i][j + 1] = cheсk;
		}
		if (j - 1 >= 0)
		{
			if (B[i][j - 1] == 0)
				B[i][j - 1] = cheсk;
		}
	return ;
}

//Поиск кратчайшего пути
int find_the_way(int* B[], int* C[], int* i, int* j, int N, int M)
{
	int res;
	if (B[*i][*j] == 3)
		res = N*M;
	else
		res = B[*i][*j];

	int inew, jnew;

	if (type_space == 0)
	{
		if ((*i - 1 >= 0) && (*j + 1 < M))
		{
			if ((B[*i - 1][*j + 1] != 0) && (B[*i - 1][*j + 1] != 1) && (B[*i - 1][*j + 1] < res) && (B[*i - 1][*j + 1] != 3))
			{
				res = B[*i - 1][*j + 1];
				inew = *i - 1;
				jnew = *j + 1;
			}
		}
		if ((*i + 1 < N) && (*j + 1 < M))
		{
			if ((B[*i + 1][*j + 1] != 0) && (B[*i + 1][*j + 1] != 1) && (B[*i + 1][*j + 1] < res) && (B[*i + 1][*j + 1] != 3))
			{
				res = B[*i + 1][*j + 1];
				inew = *i + 1;
				jnew = *j + 1;
			}
		}
		if ((*i + 1 < N) && (*j - 1 >= 0))
		{
			if ((B[*i + 1][*j - 1] != 0) && (B[*i + 1][*j - 1] != 1) && (B[*i + 1][*j - 1] < res) && (B[*i + 1][*j - 1] != 3))
			{
				res = B[*i + 1][*j - 1];
				inew = *i + 1;
				jnew = *j - 1;
			}
		}
		if ((*i - 1 >= 0) && (*j - 1 >= 0))
		{
			if ((B[*i - 1][*j - 1] != 0) && (B[*i - 1][*j - 1] != 1) && (B[*i - 1][*j - 1] < res) && (B[*i - 1][*j - 1] != 3))
			{
				res = B[*i - 1][*j - 1];
				inew = *i - 1;
				jnew = *j - 1;
			}
		}
	}
	
		if (*i + 1 < N)
		{
			if ((B[*i + 1][*j] != 0) && (B[*i + 1][*j] != 1) && (B[*i + 1][*j] < res) && (B[*i + 1][*j] != 3))
			{
				res = B[*i + 1][*j];
				inew = *i + 1;
				jnew = *j;
			}
		}
		if (*i - 1 >= 0)
		{
			if ((B[*i - 1][*j] != 0) && (B[*i - 1][*j] != 1) && (B[*i - 1][*j] < res) && (B[*i - 1][*j] != 3))
			{
				res = B[*i - 1][*j];
				inew = *i - 1;
				jnew = *j;
			}
		}
		if (*j + 1 < M)
		{
			if ((B[*i][*j + 1] != 0) && (B[*i][*j + 1] != 1) && (B[*i][*j + 1] < res) && (B[*i][*j + 1] != 3))
			{
				res = B[*i][*j + 1];
				inew = *i;
				jnew = *j + 1;
			}
		}
		if (*j - 1 >= 0)
		{
			if ((B[*i][*j - 1] != 0) && (B[*i][*j - 1] != 1) && (B[*i][*j - 1] < res) && (B[*i][*j - 1] != 3))
			{
				res = B[*i][*j - 1];
				inew = *i;
				jnew = *j - 1;
			}
		}
	
	if ((res > 3) && (res!=N*M))
	{
		C[inew][jnew] = 8;
		*i = inew;
		*j = jnew;
	}
	return res;
}

//Копия массива, которая отображает путь
void copy_dynamic_2(int* A[], int* C[], int N, int M)
{
	for (int i = 0; i < N; i++)
	{
		for (int j = 0; j < M; j++)
		{
			C[i][j] = A[i][j];
		}
	}
	return;
}

int main()
{
	int **A;
	A = (int**)malloc(N*sizeof(int*));
	for (int i = 0; i < N; i++)
		A[i] = (int*)malloc(M*sizeof(int));

	int **B;
	B = (int**)malloc(N*sizeof(int*));
	for (int i = 0; i < N; i++)
		B[i] = (int*)malloc(M*sizeof(int));

	int **C;
	C = (int**)malloc(N*sizeof(int*));
	for (int i = 0; i < N; i++)
		C[i] = (int*)malloc(M*sizeof(int));

	init_dynamic(A, N, M);
	printf("Initial data:\n\n");
	print_dynamic(A, N, M);
	printf("\n");

	//Проверка стартовой и финишной точек на их принадлежность позиции 0.
	if (check_start_finish_point(A, N, M) == 0)
		printf("Start or finish point is in the wall\n\n"); 
	else
	{
		copy_dynamic(A, B, N, M);
		//print_dynamic(B, N, M);  //Распечатать массив с проставленными точками старта и финиша
		//printf("\n");

		unsigned cheсk = 4;

		//Поиск стартовой точки и заполнение её окрестностей (цифра 4)
		for (int i = 0; i < N; i++)
		{
			for (int j = 0; j < M; j++)
			{
				if (B[i][j] == 2)
				{
					set_neib(B, i, j, N, M, cheсk);

				}
			}
		}

		// Вводим цикл по переменной zz для предотвращения возможного зацикливания, 
		//  максимальное количество итераций данного цикла не превышает количество элементов матрицы (N*M)
		for (int zz = cheсk; zz < N*M; zz++)
		{
			for (int i = 0; i < N; i++)
			{
				for (int j = 0; j < M; j++)
				{
					if (B[i][j] == zz)
					{
						set_neib(B, i, j, N, M, zz + 1);
					}
				}
			}
		}
		//print_dynamic(B, N, M);   //распечатать массив с проставленными "весами" каждой ячейки
		//printf("\n");

		copy_dynamic_2(A, C, N, M);

		int xcoord, ycoord, result_of_way;
		xcoord = finish_X;
		ycoord = finish_Y;

		//Проход по матрице, ищем минимальное значение в окружающих ячейках, начиная от финиша.
		//Координаты и значение ячейки с минимальным значением передаём в функцию поиска пути, после чего 
		//ищем минимальное значение вокруг данной ячейки.
		for (int zz = N*M; zz > 3; zz--)
		{
			result_of_way = find_the_way(B, C, &xcoord, &ycoord, N, M);

			if ((start_X == finish_X) && (start_Y == finish_Y))
			{
				printf("Start is a finish\n\n");
				break;
			}
			if (result_of_way == N*M)
			{
				printf("No way to finish :(\n\n");
				break;
			}
			else
			{
				if (result_of_way == 2)
				{
					printf("Process complete!!!\n\n");
					break;
				}
			}
		}

		C[start_X][start_Y] = 2;
		C[finish_X][finish_Y] = 3;

		print_dynamic(C, N, M);   //Печать матрицы, где восьмёрками проложен кратчайший путь
	}

	for (int i = 0; i < N; i++)
	{
		free(A[i]);
		free(B[i]);
		free(C[i]);
	}
	free(A);
	free(B);
	free(C);

	getchar();
	return 0;
}