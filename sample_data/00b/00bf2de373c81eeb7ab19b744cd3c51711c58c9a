#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#pragma warning(disable : 4996)

int main(void)
{
	//Open the key file
	FILE *key = fopen("Key.dat", "rb");
	if (key == NULL) // Check if file opened successfully
	{
		return -1;
	}

	// Open the raw data file
	FILE *raw = fopen("Raw.dat", "rb");
	if (raw == NULL) // Check if file opened successfully
	{
		return -1;
	}

	// Create an output file
	FILE *output = fopen("Encoded.dat", "wb");
	if (output == NULL)
	{
		return -1;
	}

	char base64keys[65]; // Array to store base64 keys
	fgets(base64keys, 65, key); // Read the key from the keyfile

	char sentence[1024]; // Array to store data
	fgets(sentence, 1024, raw); // Read the data from the file
	int length = 0; // Number of characters in the data
	
	// Count number of characters in the data
	while (sentence[length] != '\0')
	{
		length++;
	}

	int totalBits = length * 8; // Number of bits.
	int *bits = malloc(sizeof(int)*totalBits); // To store the bits of the data
	int bitIndex = 0; // Index of the bits array

	// Convert the data to binary
	for (int i = 0; i < length; ++i) // For each character
	{
		int ascii = sentence[i]; // Get ascii code

		// Ascii codes are 8 bit integers; loop through the 8 bits starting from the left
		for (int n = 7; n >= 0; --n)
		{
			int nthBit = ascii >> n; // Right shift the number by 'n' places
			int bit = nthBit & 1; // Determine the value of (n+1)th bit by bitwise AND operation by 1
			bits[bitIndex] = bit; // Store the bit;
			bitIndex++;
		}
	}

	int totalBase64Bytes = ceil(totalBits / 6.0);
	int *base64bits = malloc(sizeof(int)*totalBase64Bytes*8); // Stores the bits of the base64 values
	int *base64values = malloc(sizeof(int)*totalBase64Bytes); // Stores the base64 values
	int base64index = 0; // Index of the bits in the base64 array

	bitIndex = 0; // Reset the position of the current bit being used
	// For each Base64 bytes
	for (int i = 0; i < totalBase64Bytes; ++i)
	{
		int base64_key = 0; // Stores the decimal value of the base64 index

		// First two bits = 0
		base64bits[base64index] = 0;
		base64index++;
		base64bits[base64index] = 0;
		base64index++;

		// Fill the other 6 bits
		for (int currentIndex = 5; currentIndex >= 0; currentIndex--)
		{
			if (bitIndex == totalBits) // If all the bits of the ASCII values are used up
			{
				base64bits[base64index] = 0;
			}
			else
			{
				base64bits[base64index] = bits[bitIndex];
				bitIndex++;
			}
			
			base64_key += base64bits[base64index]*(pow(2,currentIndex)); // Calculate the decimal value of the base64 index
			base64index++;
		}

		base64values[i] = base64_key;
	}

	
	// Write the output file
	for (int n = 1; n <= totalBase64Bytes; n++)
	{
		fwrite(&base64keys[base64values[n-1]],1,1,output);
		// Break it in groups of 8 characters with 6 groups per line
		if (n % 8 == 0)
			fwrite(" ", 1, 1, output);
		if (n % (8*6) == 0)
			fwrite("\n", 1, 1, output);

		// Check if padding required in the end
		if (n == totalBase64Bytes)
		{
			int n_new = n;
			while (n_new % 8 != 0) // If the position is in a group of 8, pad until the group is complete
			{
				fwrite("=", 1, 1, output);
				n_new++;
			}
		}
	}

	// Close files
	fclose(key);
	fclose(raw);
	fclose(output);
	// Free memory
	free(bits);
	free(base64bits);
	return 0;
}