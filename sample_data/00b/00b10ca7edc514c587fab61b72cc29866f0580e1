--https://github.com/Mokiros/roblox-FE-compatibility
if game:GetService("RunService"):IsClient() then error("Script must be server-side in order to work; use h/ and not hl/") end
local Player,Mouse,mouse,UserInputService,ContextActionService = owner
local RealPlayer = Player
do print("FE Compatibility code by Mokiros")local a=RealPlayer;script.Parent=a.Character;local b=Instance.new("RemoteEvent")b.Name="UserInput_Event"local function c()local d={_fakeEvent=true,Functions={},Connect=function(self,e)table.insert(self.Functions,e)end}d.connect=d.Connect;return d end;local f={Target=nil,Hit=CFrame.new(),KeyUp=c(),KeyDown=c(),Button1Up=c(),Button1Down=c(),Button2Up=c(),Button2Down=c()}local g={InputBegan=c(),InputEnded=c()}local CAS={Actions={},BindAction=function(self,h,i,j,...)CAS.Actions[h]=i and{Name=h,Function=i,Keys={...}}or nil end}CAS.UnbindAction=CAS.BindAction;local function k(self,l,...)local d=f[l]if d and d._fakeEvent then for m,e in pairs(d.Functions)do e(...)end end end;f.TrigEvent=k;g.TrigEvent=k;b.OnServerEvent:Connect(function(n,o)if n~=a then return end;f.Target=o.Target;f.Hit=o.Hit;if not o.isMouse then local p=o.UserInputState==Enum.UserInputState.Begin;if o.UserInputType==Enum.UserInputType.MouseButton1 then return f:TrigEvent(p and"Button1Down"or"Button1Up")end;if o.UserInputType==Enum.UserInputType.MouseButton2 then return f:TrigEvent(p and"Button2Down"or"Button2Up")end;for m,d in pairs(CAS.Actions)do for m,q in pairs(d.Keys)do if q==o.KeyCode then d.Function(d.Name,o.UserInputState,o)end end end;f:TrigEvent(p and"KeyDown"or"KeyUp",o.KeyCode.Name:lower())g:TrigEvent(p and"InputBegan"or"InputEnded",o,false)end end)b.Parent=NLS([==[local a=game:GetService("Players").LocalPlayer;local b=script:WaitForChild("UserInput_Event")local c=a:GetMouse()local d=game:GetService("UserInputService")local e=function(f,g)if g then return end;b:FireServer({KeyCode=f.KeyCode,UserInputType=f.UserInputType,UserInputState=f.UserInputState,Hit=c.Hit,Target=c.Target})end;d.InputBegan:Connect(e)d.InputEnded:Connect(e)local h,i;while wait(1/30)do if h~=c.Hit or i~=c.Target then h,i=c.Hit,c.Target;b:FireServer({isMouse=true,Target=i,Hit=h})end end]==],Player.Character)local r=game;local s={__index=function(self,q)local t=rawget(self,"_RealService")if t then return typeof(t[q])=="function"and function(m,...)return t[q](t,...)end or t[q]end end,__newindex=function(self,q,u)local t=rawget(self,"_RealService")if t then t[q]=u end end}local function v(d,w)d._RealService=typeof(w)=="string"and r:GetService(w)or w;return setmetatable(d,s)end;local x={GetService=function(self,t)return rawget(self,t)or r:GetService(t)end,Players=v({LocalPlayer=v({GetMouse=function(self)return f end},Player)},"Players"),UserInputService=v(g,"UserInputService"),ContextActionService=v(CAS,"ContextActionService"),RunService=v({_btrs={},RenderStepped=r:GetService("RunService").Heartbeat,BindToRenderStep=function(self,h,m,i)self._btrs[h]=self.Heartbeat:Connect(i)end,UnbindFromRenderStep=function(self,h)self._btrs[h]:Disconnect()end},"RunService")}rawset(x.Players,"localPlayer",x.Players.LocalPlayer)x.service=x.GetService;v(x,game)game,owner=x,x.Players.LocalPlayer end do --CFrame lerp (stravant, clerp by AntiBoomz0r)
        local function QuaternionFromCFrame(cf) 
                local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components() 
                local trace = m00 + m11 + m22 
                if trace > 0 then 
                        local s = math.sqrt(1 + trace) 
                        local recip = 0.5/s 
                        return (m21-m12)*recip, (m02-m20)*recip, (m10-m01)*recip, s*0.5 
                else 
                        local i = 0 
                        if m11 > m00 then
                                i = 1 
                        end 
                        if m22 > (i == 0 and m00 or m11) then 
                                i = 2 
                        end 
                        if i == 0 then 
                                local s = math.sqrt(m00-m11-m22+1) 
                                local recip = 0.5/s 
                                return 0.5*s, (m10+m01)*recip, (m20+m02)*recip, (m21-m12)*recip 
                        elseif i == 1 then 
                                local s = math.sqrt(m11-m22-m00+1) 
                                local recip = 0.5/s 
                                return (m01+m10)*recip, 0.5*s, (m21+m12)*recip, (m02-m20)*recip 
                        elseif i == 2 then 
                                local s = math.sqrt(m22-m00-m11+1) 
                                local recip = 0.5/s return (m02+m20)*recip, (m12+m21)*recip, 0.5*s, (m10-m01)*recip 
                        end 
                end 
        end
        local function QuaternionToCFrame(px, py, pz, x, y, z, w) 
                local xs, ys, zs = x + x, y + y, z + z 
                local wx, wy, wz = w*xs, w*ys, w*zs 
                local xx = x*xs 
                local xy = x*ys 
                local xz = x*zs 
                local yy = y*ys 
                local yz = y*zs 
                local zz = z*zs 
                return CFrame.new(px, py, pz,1-(yy+zz), xy - wz, xz + wy,xy + wz, 1-(xx+zz), yz - wx, xz - wy, yz + wx, 1-(xx+yy)) 
                end   
        local function QuaternionSlerp(a, b, t) 
                local cosTheta = a[1]*b[1] + a[2]*b[2] + a[3]*b[3] + a[4]*b[4] 
                local startInterp, finishInterp; 
                if cosTheta >= 0.0001 then 
                        if (1 - cosTheta) > 0.0001 then 
                                local theta = math.acos(cosTheta) 
                                local invSinTheta = 1/math.sin(theta) 
                                startInterp = math.sin((1-t)*theta)*invSinTheta 
                                finishInterp = math.sin(t*theta)*invSinTheta  
                        else 
                                startInterp = 1-t 
                                finishInterp = t 
                        end 
                else
                        if (1+cosTheta) > 0.0001 then 
                                local theta = math.acos(-cosTheta) 
                                local invSinTheta = 1/math.sin(theta) 
                                startInterp = math.sin((t-1)*theta)*invSinTheta 
                                finishInterp = math.sin(t*theta)*invSinTheta 
                        else 
                                startInterp = t-1 
                                finishInterp = t 
                        end 
                end 
                return a[1]*startInterp + b[1]*finishInterp, a[2]*startInterp + b[2]*finishInterp, a[3]*startInterp + b[3]*finishInterp, a[4]*startInterp + b[4]*finishInterp 
        end  
        function clerp(a,b,t) 
                local qa = {QuaternionFromCFrame(a)}
                local qb = {QuaternionFromCFrame(b)} 
                local ax, ay, az = a.x, a.y, a.z 
                local bx, by, bz = b.x, b.y, b.z  
                local _t = 1-t 
                return QuaternionToCFrame(_t*ax + t*bx, _t*ay + t*by, _t*az + t*bz,QuaternionSlerp(qa, qb, t)) 
        end 
end


do --rayCast
    function rayCast(startpos, Speed, Gravity, Dmg)
        local ran,err = ypcall(function()
    local rayPart         = Instance.new("Part", char)
    rayPart.Name          = "RayPart"
    rayPart.BrickColor    = BrickColor.new("Really red")
    rayPart.Anchored      = true
    rayPart.Shape         = Shape or "Ball"
    rayPart.CanCollide    = false
	rayPart.Locked        = true
    rayPart.TopSurface    = Enum.SurfaceType.Smooth
    rayPart.BottomSurface = Enum.SurfaceType.Smooth
    rayPart.Size          = Vector3.new(.2, 2, .2)
    local msh = Instance.new("SpecialMesh",rayPart)
    msh.MeshId = "http://www.roblox.com/asset/?id=16190555"
    msh.TextureId = "http://www.roblox.com/asset/?id=16190577"
    msh.Scale = Vector3.new(2, 2, 2)

	
	

    local bulletposition = startpos.Position
    rayPart.CFrame = startpos.CFrame

   local bulletvelocity = (Vector3.new(math.random(-2,2), math.random(-2,2), math.random(-2,2)))+( mouse.Hit.p - bulletposition).unit*Speed
    local bulletlastposition = bulletposition


    
        coroutine.resume(coroutine.create(function()
        while true do
	        local dt = wait()
            bulletlastposition = bulletposition
            bulletvelocity = bulletvelocity + (Vector3.new(0, -3.81*Gravity, 0)*dt)
	        bulletposition = bulletposition + (bulletvelocity*dt)
                
            local ray = Ray.new(bulletlastposition,  (bulletposition - bulletlastposition))

            local hit, hitposition = workspace:FindPartOnRayWithIgnoreList( ray, { char, rayPart, camera} )
	            
	if (torso.Position - rayPart.Position).magnitude > 540 then
	 	rayPart:Destroy()
	 break
	 end
	
	
            if hit then
					local damage = math.random(Dmg, Dmg+6)
				if hit.Parent:findFirstChild("Humanoid") ~= nil then
					hit.Parent.Humanoid.Health = hit.Parent.Humanoid.Health - damage
				elseif hit.Parent:IsA("Hat") and hit.Parent.Parent:findFirstChild("Humanoid") then
				    hit.Parent.Parent.Humanoid.Health = hit.Parent.Parent.Humanoid.Health - damage
			    end
				bulletposition = hitposition
                rayPart.CFrame = CFrame.new(bulletposition, bulletposition+bulletvelocity) * CFrame.Angles(math.pi/2, 0, 0)
                for i = 1, 50 do
		    local s = Instance.new("Part")
		s.CanCollide = false
		s.Shape = 1
		s.Locked = true
		s.formFactor = "Custom"
		pl = Instance.new("PointLight", s)
		pl.Range = 8
		pl.Color = Color3.new(0.8, 0.8, 0)
		s.Size = Vector3.new(.3,.3,.3)
		s.Transparency = 0.5
		s.BrickColor = BrickColor.new("Brick yellow")
		local v = Vector3.new(math.random(-1,1), math.random(1,2), math.random(-1,1))
		s.Velocity = 0.5 * v
	