let store = [];
const storeSize = 10;
let h = t = -1;
let size = 0
let emptySpaces = 0;

let entry = function() {
	this.num = -1;
	this.prev = -1;
	this.next = -1;
}

function addValue(e) {
	
	let newEntry = new entry();
	newEntry.num = e;
	newEntry.next = -1;
	let added = false;
	
	if(size == 0) {
		h = t = 0;
		newEntry.prev = -1;
		store[t] = newEntry;
	} else {

		if(size >= storeSize) {
			store[h].num = e;
			store[h].prev = t;
			store[t].next = h;
			t = h;
			h = store[h].next;
			store[h].prev = -1;
			store[t].next = -1;
		} else {

			if(emptySpaces == 0) {
				
				store[t].next = t+1;
				t = t+1;
				store[t] = newEntry;
				store[t].prev = t-1;
				
			} else {
				/*for(let i=0; i<storeSize; ++i); {
					
				}*/
				let i = (t+1)%storeSize;
				while(!added) {
					if(store[i].next == -1 && store[i].prev == -1) {
						store[t].next = i;
						store[i] = newEntry
						store[i].prev = t;
						t = i;
						added = true;
					}
					i = (i+1)%storeSize;
				}
				
				emptySpaces--;
			}
			/*store[t].next = (t+1)%storeSize;
			newEntry.prev = t;
			t = (t+1)%storeSize;
			store[t] = newEntry;*/
		}
	}

	if(size < storeSize) {
		size++;
	}
}

function getCount(e) {
	let count = 0;

	let copyH = h;
	
	if(copyH == -1) {
		return 0;
	}
	
	while(copyH != -1) {
		if(store[copyH].num == e) {
			count++;
		}
		copyH = store[copyH].next;
	}

	return count;
}

addValue(1);
for(let i=0; i<4; ++i) {
	addValue(99);
}
addValue(6);
addValue(99);
addValue(7);
addValue(99);
addValue(99);


function removeValue(e) {
	let removed = false;

	let tempH = h;
	let move = 0;
	let entriesRemoved = 0;

	if(store[h].num == e) {
		while(tempH != t) {

			if(store[tempH].num == e) {
				move++;
				entriesRemoved++;
			} else {
				break;
			}
			store[tempH].prev = -1;
			tempH = store[tempH].next;
			store[store[tempH].prev].next = -1;
		}

		if(tempH == t && store[tempH].num == e) {
			
			store[tempH].prev = -1;
			store[tempH].next = -1;
			h = t = -1;
			size = 0;
			emptySpaces += (move+1);
			return true;
		
		} else {

			store[h].next = -1
			store[h].prev = -1;
			h = tempH;
			store[h].prev = -1;
			removed = true;

		}
	}
	
	move = 0;
	if(store[t].num == e) { // When tail has to be removed.
		tempH = t;
		while(store[tempH].num == e) {
			move++;
			entriesRemoved++;
			store[tempH].next = -1;
			tempH = store[tempH].prev;
			store[store[tempH].next].prev = -1;
		}

		store[t].prev = -1;
		store[t].next = -1;
		t = tempH;
		store[t].next = -1;
		tempH = h;
		removed = true;
	}

	while(tempH != -1) {

		if(store[tempH].num == e) {
			removed = true;

			let move = 0;
			//let copyofCopyH = tempH;
			let prevEnt = store[tempH].prev;
			while(store[tempH].num == e) {
				move++;
				entriesRemoved++;
				store[tempH].prev = -1;
				tempH = store[tempH].next;
				store[store[tempH].prev].next = -1;
			}

			store[prevEnt].next = tempH;
			store[tempH].prev = prevEnt;
		}

		tempH = store[tempH].next;

	}

	size = size-entriesRemoved;
	console.log(entriesRemoved);
	emptySpaces += entriesRemoved;
	return removed;

}

function removeValueNew(e) {
	let removed = false;

	if(size == 0) {
		return removed;
	}

	let entriesRemoved = 0; // Initially, no entries have been removed.

	let tempH = h; // A copy of head, for traversing the list without actually changing the head.


	//Cases where we have to remove head or tail.
	let move = 0;

	// When Head has to be removed.
	if(store[h].num == e) {
		while(tempH != -1) {

			if(store[tempH].num == e) {
				move++;
			} else {
				break;
			}
			tempH = store[tempH].next;
		}

		if(tempH == -1) {
		
			h = t = -1;
			size = 0;
			return true;
		
		} else {

			h = (h+move)%storeSize;
			store[store[h].prev].next = -1
			store[h].prev = -1;
			entriesRemoved += move;
			tempH = h;
			removed = true;

		}
	} else if(store[t].num == e) { // When tail has to be removed.
		tempH = t;
		while(store[tempH].num == e) {
			move++;
			tempH = store[tempH].prev;
		}

		t = (storeSize+t-move)%storeSize;
		store[store[t].next].prev = -1;
		store[t].next = -1;
		entriesRemoved += move;
		tempH = h;
		removed = true;
	}

	while(tempH != t) {

		if(store[tempH].num == e) {

			removed = true;

			let tailForShifting = tempH; // A copy of tempH which will help traverse the list without modifying the tempH.
			let shiftN = 0; // How many times to shift the next element which is not equal to the element being removed.

			while(store[tailForShifting].num == e && tailForShifting != t) { // Increase shitN until we find the element which is different from the one being removed and we haven not reached the end of the lsit.
				shiftN++;
				tailForShifting = store[tailForShifting].next;
			}

			let headForShifting = tempH; // Make yet another copy of tempH for updating list. 
			
			while(tailForShifting != -1) { // This loop will shift n-th element shiftN blocks.

				store[headForShifting].num = store[tailForShifting].num; // Actually copy elements.

				headForShifting = store[headForShifting].next; // Move to the next entry to replace it with correct data.
				tailForShifting = store[tailForShifting].next; // Move to the next entry to be copied.
			}
			
			entriesRemoved += shiftN; // Let removed entries reflect the number of entries shifted.
			t = store[headForShifting].prev;
			store[t].next = -1;

		}

		if(tempH == t) {
			break;
		}

		tempH = store[tempH].next;
	}

	if(store[tempH].num == e) {
		t = store[tempH].prev;
		store[t].next = -1;
		entriesRemoved++;
	}

	size = size - entriesRemoved;
	return removed;
}

function removeValueBefore(e) {
	let removed = false;
	let entries = getCount(e);

	if(entries == 0) { // If the store is empty then there is nothing to remove, return removed(false).
		return removed;
	}

	// Now, if there is something to remove then do this.


	if(size == entries) { // If all the entries are to be removed then set the head and tail to point to a null index, set the size to 0, and return removed(true).
		h = t = -1;
		size = 0;
		removed = true;
		return removed;
	}

	let entriesRemoved = 0; // Initially, no entries have been removed.

	let tempH = h; // A copy of head, for traversing the list without actually changing the head.

	while(tempH != t) { // Loop until we reach the last element in the list.
		
		if(store[tempH].num == e) { // If the entry to be removed has been found..

			let tailForShifting = tempH; // A copy of tempH which will help traverse the list without modifying the tempH.
			let shiftN = 0; // How many times to shift the next element which is not equal to the element being removed. 

			while(store[tailForShifting].num == e && tailForShifting != t) { // Increase shitN until we find the element which is different from the one being removed and we haven not reached the end of the lsit.
				shiftN++;
				tailForShifting = store[tailForShifting].next;
			}


			let headForShifting = tempH; // Make yet another copy of tempH for updating list. 
			
			while(tailForShifting != -1) { // This loop will shift n-th element shiftN blocks.

				store[headForShifting].num = store[tailForShifting].num; // Actually copy elements.

				headForShifting = store[headForShifting].next; // Move to the next entry to replace it with correct data.
				tailForShifting = store[tailForShifting].next; // Move to the next entry to be copied.
			}
			
			entriesRemoved += shiftN; // Let removed entries reflect the number of entries shifted.
			t = store[headForShifting].prev;
			store[t].next = -1;

			// Pray that everything has been removed.
		}
		
		if(tempH == t) {
			break;
		}
		
		tempH = store[tempH].next; // Go to the next element in the list.
	}

	// If the element at the tail has to be removed then do this.
	if(store[tempH].num == e) {
		t = store[tempH].prev;
		store[t].next = -1;
		entriesRemoved++;
	}

	if(entriesRemoved == entries) {
		removed = true;
	}

	size = size - entriesRemoved;
	return removed;
}

function ps() {
	let retVal = "";
	
	let copyH = h;
	
	if(copyH == -1) {
		return "";
	}
	
	while(copyH != -1) {
		retVal += store[copyH].num + " ";
		copyH = store[copyH].next;
	}

	return retVal;
}

function addFromArray(arr) {

	for(let i=0; i<arr.length; ++i) {
		addValue(arr[i]);
	}
}

function del() {
	store = [];
	h = t = -1;
	size = 0;
	emptySpaces = 0;
	return "deleted";
}