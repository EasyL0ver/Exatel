static void Encrypt00(byte[] src, int start) {
            int dataLen = src.Length - start;
            int temp1, temp2;

            if (dataLen >= 32) {

                // bit on/off according to other bit
                temp1 = src[start + 0x13];
                temp1 >>= 3;
                temp1 &= 1;

                temp2 = src[start + 0x13];
                temp2 >>= 5;
                temp2 &= 1;

                if (temp1 == 0) {
                    src[start + 0x13] &= 0xDF;
                } else {
                    src[start + 0x13] |= 0x20;
                }
                if (temp2 == 0) {
                    src[start + 0x13] &= 0xF7;
                } else {
                    src[start + 0x13] |= 0x08;
                }

                // swap byte 7 and F
                temp1 = src[start + 7];
                src[start + 7] = src[start + 0x0F];
                src[start + 0x0F] = (byte)temp1;

                // swap byte 7 and 0x17
                temp1 = src[start + 7];
                src[start + 7] = src[start + 0x17];
                src[start + 0x17] = (byte)temp1;

                // ROR src[start + 2], 7
                temp1 = src[start + 2];
                src[start + 2] = (byte)(((temp1 >> 7) & 0xFF) | ((temp1 << (8 - 7)) & 0xFF));

                // swap byte B and 0x16
                temp1 = src[start + 0x0B];
                src[start + 0x0B] = src[start + 0x16];
                src[start + 0x16] = (byte)temp1;

                // swap byte 0x19 and 0x0F
                temp1 = src[start + 0x19];
                src[start + 0x19] = src[start + 0x0F];
                src[start + 0x0F] = (byte)temp1;

                // swap byte 0x1D and 0x1F
                temp1 = src[start + 0x1D];
                src[start + 0x1D] = src[start + 0x1F];
                src[start + 0x1F] = (byte)temp1;

                // ROR src[start + 0x10], 7
                temp1 = src[start + 0x10];
                src[start + 0x10] = (byte)(((temp1 >> 7) & 0xFF) | ((temp1 << (8 - 7)) & 0xFF));

                // ROR src[start + 0x17], 2
                temp1 = src[start + 0x17];
                src[start + 0x17] = (byte)(((temp1 >> 2) & 0xFF) | ((temp1 << (8 - 2)) & 0xFF));

                // swap byte 0x14 and 0x0C
                temp1 = src[start + 0x14];
                src[start + 0x14] = src[start + 0x0C];
                src[start + 0x0C] = (byte)temp1;

                // bit on/off according to other bit
                temp1 = src[start + 0x0B];
                temp1 >>= 3;
                temp1 &= 1;

                temp2 = src[start + 0x0B];
                temp2 >>= 4;
                temp2 &= 1;

                if (temp1 == 0) {
                    src[start + 0x0B] &= 0xEF;
                } else {
                    src[start + 0x0B] |= 0x10;
                }
                if (temp2 == 0) {
                    src[start + 0x0B] &= 0xF7;
                } else {
                    src[start + 0x0B] |= 0x08;
                }

                // ROR src[start + 7], 2
                temp1 = src[start + 7];
                src[start + 7] = (byte)(((temp1 >> 2) & 0xFF) | ((temp1 << (8 - 2)) & 0xFF));

                // bit on/off according to other bit
                temp1 = src[start + 0x07];
                temp1 >>= 1;
                temp1 &= 1;

                temp2 = src[start + 0x07];
                temp2 >>= 2;
                temp2 &= 1;

                if (temp1 == 0) {
                    src[start + 0x07] &= 0xFB;
                } else {
                    src[start + 0x07] |= 0x04;
                }
                if (temp2 == 0) {
                    src[start + 0x07] &= 0xFD;
                } else {
                    src[start + 0x07] |= 0x02;
                }

            } else if (dataLen >= 16) {
                
                // swap byte 1 and 6
                temp1 = src[start + 1];
                src[start + 1] = src[start + 6];
                src[start + 6] = (byte)temp1;

                // bit on/off according to other bit
                temp1 = src[start + 5];
                temp1 >>= 2;
                temp1 &= 1;

                temp2 = src[start + 5];
                temp2 >>= 6;
                temp2 &= 1;

                if (temp1 == 0) {
                    src[start + 5] &= 0xBF;
                } else {
                    src[start + 5] |= 0x40;
                }
                if (temp2 == 0) {
                    src[start + 5] &= 0xFB;
                } else {
                    src[start + 5] |= 0x04;
                }

                // swap byte 9 and F
                temp1 = src[start + 9];
                src[start + 9] = src[start + 0x0F];
                src[start + 0x0F] = (byte)temp1;

                // swap byte 0 and 3
                temp1 = src[start];
                src[start] = src[start + 3];
                src[start + 3] = (byte)temp1;

                // xor
                src[start + 8] ^= 0x05;

            } else if (dataLen >= 8) {

                // swap byte 5 and 6
                temp1 = src[start + 5];
                src[start + 5] = src[start + 6];
                src[start + 6] = (byte)temp1;

                // swap byte 4 and 7
                temp1 = src[start + 4];
                src[start + 4] = src[start + 7];
                src[start + 7] = (byte)temp1;

                // ROR src[start], 7
                temp1 = src[start];
                src[start] = (byte)(((temp1 >> 7) & 0xFF) | ((temp1 << (8 - 7)) & 0xFF));

                // ROR src[start + 2], 4
                temp1 = src[start + 2];
                src[start + 2] = (byte)(((temp1 >> 4) & 0xFF) | ((temp1 << (8 - 4)) & 0xFF));

                // ROR src[start + 2], 4 - yes, the same as above ^^ so it reverts back
                temp1 = src[start + 2];
                src[start + 2] = (byte)(((temp1 >> 4) & 0xFF) | ((temp1 << (8 - 4)) & 0xFF));

                // ROR src[start + 7], 1
                temp1 = src[start + 7];
                src[start + 7] = (byte)(((temp1 >> 1) & 0xFF) | ((temp1 << (8 - 1)) & 0xFF));

                // ROR src[start + 2], 3
                temp1 = src[start + 2];
                src[start + 2] = (byte)(((temp1 >> 3) & 0xFF) | ((temp1 << (8 - 3)) & 0xFF));

                // swap byte 5 and 3
                temp1 = src[start + 5];
                src[start + 5] = src[start + 3];
                src[start + 3] = (byte)temp1;

            } else if (dataLen >= 4) {
                throw new NotSupportedException("Missing L2: " + Enc.PrintMemory(src));
            }
        }

        static void Decrypt00(byte[] src, int start) {
            int dataLen = src.Length - start;
            int temp1, temp2;

            if (dataLen >= 32) {

                // bit on/off according to other bit
                temp1 = src[start + 0x07];
                temp1 >>= 1;
                temp1 &= 1;

                temp2 = src[start + 0x07];
                temp2 >>= 2;
                temp2 &= 1;

                if (temp1 == 0) {
                    src[start + 0x07] &= 0xFB;
                } else {
                    src[start + 0x07] |= 0x04;
                }
                if (temp2 == 0) {
                    src[start + 0x07] &= 0xFD;
                } else {
                    src[start + 0x07] |= 0x02;
                }

                // ROL src[start + 7], 2
                temp1 = src[start + 7];
                src[start + 7] = (byte)(((temp1 << 2) & 0xFF) | ((temp1 >> (8 - 2)) & 0xFF));

                // bit on/off according to other bit
                temp1 = src[start + 0x0B];
                temp1 >>= 3;
                temp1 &= 1;

                temp2 = src[start + 0x0B];
                temp2 >>= 4;
                temp2 &= 1;

                if (temp1 == 0) {
                    src[start + 0x0B] &= 0xEF;
                } else {
                    src[start + 0x0B] |= 0x10;
                }
                if (temp2 == 0) {
                    src[start + 0x0B] &= 0xF7;
                } else {
                    src[start + 0x0B] |= 0x08;
                }

                // swap byte 0x14 and 0x0C
                temp1 = src[start + 0x14];
                src[start + 0x14] = src[start + 0x0C];
                src[start + 0x0C] = (byte)temp1;

                // ROL src[start + 0x17], 2
                temp1 = src[start + 0x17];
                src[start + 0x17] = (byte)(((temp1 << 2) & 0xFF) | ((temp1 >> (8 - 2)) & 0xFF));

                // ROL src[start + 0x10], 7
                temp1 = src[start + 0x10];
                src[start + 0x10] = (byte)(((temp1 << 7) & 0xFF) | ((temp1 >> (8 - 7)) & 0xFF));

                // swap byte 0x1D and 0x1F
                temp1 = src[start + 0x1D];
                src[start + 0x1D] = src[start + 0x1F];
                src[start + 0x1F] = (byte)temp1;

                // swap byte 0x19 and 0x0F
                temp1 = src[start + 0x19];
                src[start + 0x19] = src[start + 0x0F];
                src[start + 0x0F] = (byte)temp1;

                // swap byte B and 0x16
                temp1 = src[start + 0x0B];
                src[start + 0x0B] = src[start + 0x16];
                src[start + 0x16] = (byte)temp1;

                // ROL src[start + 2], 7
                temp1 = src[start + 2];
                src[start + 2] = (byte)(((temp1 << 7) & 0xFF) | ((temp1 >> (8 - 7)) & 0xFF));

                // swap byte 7 and 0x17
                temp1 = src[start + 7];
                src[start + 7] = src[start + 0x17];
                src[start + 0x17] = (byte)temp1;

                // swap byte 7 and F
             