public interface IVLCObject : IDisposable
{
    IntPtr ObjectHandle { get; }

    bool IsInvalid { get; }
}
	
public interface IVLCMedia : IVLCObject
{
    Uri Location { get; }
    void AddOption(string mediaOption);
    long Duration { get; }
    ...
}
	
public interface IVLCMediaPlayer : IVLCObject
{
    IVLCMedia Media { get; set; }
    bool Play();
    void Pause();
    void Stop();
    ...
}
	
internal class VLCMediaPlayer
    : VLCObject<VLCMediaPlayer.libvlc_media_player_release_t>, IVLCMediaPlayer
{
    public VLCMediaPlayer(IVLCObject vlcObject)
        : base(libvlc_media_player_new(vlcObject,
            vlcObject.GetType().GetInterface("IVLCMedia") != null), libvlc_media_player_release)
    {
    }

    ....

    private static IntPtr libvlc_media_player_new(IVLCObject vlcObject, bool fromMedia = false)
    {
        return Environment.Is64BitProcess
            ? fromMedia
                ? libvlc_media_player_new_from_media64(vlcObject.ObjectHandle)
                : libvlc_media_player_new64(vlcObject.ObjectHandle)
            : fromMedia
                ? libvlc_media_player_new_from_media32(vlcObject.ObjectHandle)
                : libvlc_media_player_new32(vlcObject.ObjectHandle);
    }
}
	
public static bool Implements<UInterface>(this object Object) => 
    Object.GetType().GetInterface(typeof(UInterface).Name) != null;
	
public static bool Implements<UInterface>(this object Object)
{
    Type interfaceType = typeof(UInterface);
    return Object.GetType().GetInterfaces().Contains(interfaceType);
}
	
public static bool Implements<UInterface>(this object Object) => Object is UInterface;
	
public static bool Implements<UInterface>(this object Object) => 
    typeof(UInterface).IsAssignableFrom(Object.GetType());
	
public static bool Implements<UInterface>(this object Object) => 
    typeof(UInterface).IsInstanceOfType(Object);
	
public static bool Implements<UInterface>(this object Obj)
{
    unsafe
    {
        // Получим MT Pointer нашего интерфейса
        IntPtr iMTPointer = typeof(UInterface).TypeHandle.Value;

        // Получим ссылку на объект
        TypedReference trObj = __makeref(Obj);
        IntPtr ptrObj = **(IntPtr**)&trObj;

        // Из ссылки на объект перейдем к заветной таблице методов
        IntPtr* methodTable = (IntPtr*)(*(IntPtr*)ptrObj.ToPointer()).ToPointer();

        // Перейдем к разделу реализуемых интерфейсов
        IntPtr* interfaces = (IntPtr*)methodTable[9].ToPointer();
        // Если объект не реализует интерфейсов вовсе, то мы получим нулевой указатель
        if (interfaces == null)
            return false;

        // Сразу за разделом интерфейсов следует раздел методов
        // До него мы, собственно, идти и будем
        IntPtr* methods = (IntPtr*)methodTable[10].ToPointer();

        for (; interfaces < methods; ++interfaces)
            // Разыменовываем текущий указатель и сверяем, 
            // равно ли его значение искомому
            if (*interfaces == iMTPointer)
                return true;

        // Если в цикле ничего найдено не было, возвращаем false
        return false;
    }
}
	
|               Method |       Mean |      Error |     StdDev |     Median | Ratio | RatioSD | Rank |
|--------------------- |-----------:|-----------:|-----------:|-----------:|------:|--------:|-----:|
| #0 CompileTimeString | 379.808 ns |  7.3281 ns |  7.5254 ns | 380.619 ns |  1.00 |    0.00 |    6 |
|     #0 RunTimeString | 428.352 ns | 12.5997 ns | 36.7538 ns | 419.475 ns |  1.15 |    0.08 |    7 |
|                   #1 | 200.056 ns |  5.1834 ns | 14.8722 ns | 191.448 ns |  0.53 |    0.05 |    5 |
|                   #2 |   8.363 ns |  0.0859 ns |  0.0803 ns |   8.321 ns |  0.02 |    0.00 |    1 |
|                   #3 |  62.209 ns |  0.6735 ns |  0.6300 ns |  62.278 ns |  0.16 |    0.00 |    4 |
|                   #4 |  41.878 ns |  0.3018 ns |  0.2675 ns |  41.813 ns |  0.11 |    0.00 |    3 |
|                   #5 |  16.117 ns |  0.2061 ns |  0.1827 ns |  16.001 ns |  0.04 |    0.00 |    2 |