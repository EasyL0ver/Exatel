#include <iostream>
#include <fstream>

using namespace std;

ifstream in ("cerc.in");
ofstream out ("cerc.out");

void Sortare (int v[], int n)
{
    for (int i=1; i<n; i++)
    {
        int q=i;
        for (int j=i+1; j<=n; j++)
            if (v[q]>v[j])
                q=j;
        if (q!=i)
        {
            int aux=v[i];
            v[i]=v[q];
            v[q]=aux;
        }
    }
}

int main()
{
    int n, v[11], a[11];
    in>>n;
    for (int i=1; i<=n; i++)
        in>>v[i];

    Sortare (v, n);

    a[1]=v[1];
    int k1=2, k2=n;
    for (int i=2; i<=n; i++)
    {
        if (i%2==0)
        {
            a[k1]=v[i];
            k1++;
        }
        else
        {
            a[k2]=v[i];
            k2--;
        }
    }

    for (int i=1; i<=n; i++)
        out<<a[i]<<" ";

    return 0;
}//cerc
#include <bits/stdc++.h>
#define nmax 15
using namespace std;
ifstream fin("permpf.in");
ofstream fout("permpf.out");
int st[nmax], n, v[nmax];

void Citire_Memorare()
{
    fin >> n;
    for(int i = 1; i <= n; i++)
    v[i] = i;
}

void Afisare()
{
    for(int t = 1; t <= n; t++)
    fout << st[t] << " ";
    fout << endl;
}

int Verificare(int u)
{
    for(int y = 1; y < u; y++)
    if(st[y] == st[u]) return 0;
    if(st[u] == v[u]) return 0;
    return 1;
}

void Backtracking_Recursiv(int q)
{
    if(q == n + 1) Afisare();
    for(int w = 1; w <= n; w++)
    {
        st[q] = w;
        if(Verificare(q))
        Backtracking_Recursiv(q + 1);
    }
}
int main()
{
    Citire_Memorare();
    Backtracking_Recursiv(1);
    return 0;
}//permpf
#include <bits/stdc++.h>
#define nmax 15
using namespace std;
int st[nmax], v[nmax], n, t;
ifstream fin("shuffle.in");
ofstream fout("shuffle.out");

void Cititire()
{
   fin >> n;
   for(int i = 1; i <= n; i++)
        fin >> v[i];
}

void Afisare()
{
    t = 1;
    for(int t = 1; t <= n; t++)
        fout << st[t] << " ";
    fout << endl;
}

void Initiere(int x)
{st[x] = 0;}

int Succesor(int k)
{
    if(st[k] < n){st[k]++; return 1;}
    return 0;
}

int Final(int q){ return (q == n+1);}

int Verificare(int x, int y)
{
    int poz;
    for(int w = 1; w <= n; w++)
      if(v[w] == x){ poz = w; break;}
    if(poz > 1 && v[poz - 1] == y) return 0;
    if(poz < n && v[poz + 1] == y) return 0;
    return 1;
}

int Conditie(int y)
{
    for(int r = 1; r < y; r++) if(st[r] == st[y]) return 0;
    if(y > 1 && (Verificare(st[y], st[y - 1]) == 0)) return 0;
    return 1;
}

void Backtracking_Recursiv(int poz1)
{
    if(Final(poz1)) Afisare();
    else { Initiere(poz1);
    while(Succesor(poz1))
    if(Conditie(poz1)) Backtracking_Recursiv(poz1 + 1);
}}

int main()
{
    Cititire();
    Backtracking_Recursiv(1);
    if(t != 1) fout <<"nu exista";
    return 0;
}//shuflle
#include <bits/stdc++.h>
#define nmax 15
using namespace std;
int st[nmax], n, N;
char cuv[nmax]; /// declar cuvantul
char lit[nmax]; /// declar un vector care ii va memora literele
int nr[nmax]; /// declar une vector care va memora de cate ori apare litera Ã®n cuvant
ifstream fin("permrep.in");
ofstream fout("permrep.out");

void Citire_Memorare()
{
    int i, j;
    fin >> cuv;
    n = 0, N = strlen(cuv);
    for(i = 0; cuv[i] != 0; i++)
    {
     for(j = 1; j <= n && cuv[i] != lit[j]; j++); ///cautam pozitia literei din cuv care nu se afla in lit
     if(j > n) ///daca nu s-a gasit litera, o introducem in lit
     {
         n++;
         lit[n] = cuv[i];
         nr[n] = 1;
     }
     else nr[j]++; /// altfel ii incrementam nr de apartitii
    }
    for(i = 1; i < n; i++) /// le sortam dupa litere
    {
        for(j = i + 1; j <= n; j++)
            if(lit[j] < lit[i])
            {
             char ch = lit[i];
             lit[i] = lit[j];
             lit[j] = ch;
             int x = nr[i];
             nr[i] = nr[j];
             nr[j] = x;
            }
    }
}
void Afisare()
{
    for(int t = 1; t <= N; t++)
        fout << lit[st[t]];
    fout << "\n";
}
void Backtracking_recursiv(int pozitie)
{
    if(pozitie == N + 1) Afisare();
    else for(int p = 1; p <= n; p++)
        if(nr[p] > 0)
        {
         nr[p]--;
         st[pozitie] = p;
         Backtracking_recursiv(pozitie + 1);
         nr[p]++;
        }
}
int main()
{
    Citire_Memorare();
    Backtracking_recursiv(1);
    return 0;
}//permrep
#include <fstream>
#define nmax 11
using namespace std;
int mat[nmax][nmax], ok[nmax], n, per[nmax], smax = 0;
ifstream cin("summax.in");
ofstream cout("summax.out");
 
void Citire()
{
   cin >> n;
   for(int i = 1; i <= n; i++)
      for(int j = 1; j <= n; j++)
        cin >> mat[i][j];
}
 
void Calcul()
{
    int sum = 0;
    for(int i = 1; i <= n; i++)
         sum += mat[i][per[i]];
    if(smax < sum)
    smax = sum;
//    cout << sum << " ";
}
 
int Verif(int u)
{
    for(int p = 1; p < u; p++)
    if(per[u] == per[p]) return 0;
    return 1;
}
 
void Backtracking_Recursiv(int k)
{
    if(k == n + 1) Calcul();
    else {for(int y = 1; y <= n; y++)
    if(ok[y] == 0)
    {
        ok[y] = 1;
        per[k] = y;
        if(Verif(k)) Backtracking_Recursiv(k + 1);
        ok[y] = 0;
    }}
}
 
int main()
{
    Citire();
    Backtracking_Recursiv(1);
    cout << smax;
    return 0;
}//summax
#include <iostream>
#include <fstream>
using namespace std;
ifstream fin("submultimi1.in");
ofstream fout("submultimi1.out");
int n,v[100],ok=0;
void citire()
{
    fin>>n;
}
void afisare(int y)
{
    for(int i=1; i<=y; i++)
    fout << v[i]<<" ";
    fout << endl;
}
bool verificare(int t)
{
    for(int i=1; i<t; i++)
    if(v[i]>=v[t] or v[t]-v[i]<=1 )return false;
    return true;
}
void backtracking(int q)
{
    while(q>0)
    {
        while(q>0 && q<=n)
        {
            v[q]++;
            if(v[q]>n)
            {
                v[q]=0;
                q--;
            }
            else
            if(verificare(q)){afisare(q); q++; }
        }
        if(q>n){
            q=n;
    }}
}
int main()
{
   citire();
   backtracking(1);
   return 0;
}//submt1
#include <iostream>
#include <fstream>
using namespace std;
ifstream fin("submultimi.in");
ofstream fout("submultimi.out");
int n,v[100],ok=0;
void citire()
{
    fin>>n;
}
void afisare(int y)
{
    for(int i=1; i<=y; i++)
    fout << v[i]<<" ";
    fout << endl;
}
bool verificare(int t)
{
    for(int i=1; i<t; i++)
    if(v[i]>=v[t])return false;
    return true;
}
void backtracking(int q)
{
    while(q>0)
    {
        while(q>0 && q<=n)
        {
            v[q]++;
            if(v[q]>n)
            {
                v[q]=0;
                q--;
            }
            else
            if(verificare(q)){afisare(q); q++; }
        }
        if(q>n){
            q=n;
    }}
}
int main()
{
   citire();
   backtracking(1);
   return 0;
}//submt
#include <bits/stdc++.h>
using namespace std;
ifstream fin("sirab.in");
ofstream fout("sirab.out");
int n,v[100],S,nr=0;
void citire()
{
    fin>>S>>n;
}
void afisare()
{
    for(int t=1; t<=n; t++)
    {
        fout  << v[t] << " ";
    }
    fout << endl;
}
bool verificare (int y)
{
    for(int i=1; i<y; i++)
        if(v[i]>=v[y] || (v[y]+v[i])%(v[y]-v[i])!=0)
        return 0;
    return 1;
}
void backtracking(int h)
{
    while(h>0)
    {
        while(h>0 && h<=n)
        {
            v[h]++;
            if(v[h]>S)
            {
                v[h]=0;
                h--;
            }
            else{if(verificare(h)) h++;}
        }
        if(h>n)
        {
            afisare();
            nr++;
            h=n;
        }
    }
}
int main()
{
    citire();
    backtracking(1);
    if(nr==0)
        fout<<'0';
    return 0;
}//sirab