#include <linux/init.h>             // Macros used to mark up functions e.g., __init __exit
#include <linux/module.h>           // Core header for loading LKMs into the kernel  /* Needed by all modules */
#include <linux/kernel.h>           // Contains types, macros, functions for the kernel
#include <linux/slab.h>
#include <linux/types.h>
#include <linux/syscalls.h>
#include <linux/sched.h>
#include <asm/uaccess.h>
#include <asm/unistd.h>
#include <asm/page.h>
#include <linux/kallsyms.h>
#include <linux/semaphore.h>
#include <asm/cacheflush.h>
#include <linux/set_memory.h>
#include <linux/cred.h>
#include <linux/user.h>



#define GPF_DISABLE write_cr0(read_cr0() & (~ 0x10000))
#define GPF_ENABLE write_cr0(read_cr0() | 0x10000)

MODULE_LICENSE("GPL");                                     ///< The license type -- this affects runtime behavior
MODULE_AUTHOR("aMiT"); 
MODULE_VERSION("0.1");

static int uid;
module_param(uid, int, 0644);

asmlinkage long (*original_call) ( const char __user *filename, int flags, umode_t mode );
asmlinkage long my_sys_READ(unsigned int fd, char __user *buf, size_t count);
asmlinkage long my_sys_OPEN(const char __user *filename, int flags, umode_t mode );
int isFileBlockedByName(const char * filename);
unsigned long* find_sys_call_table(void);
void set_page_rw( unsigned long addr);
void set_page_ro( unsigned long addr);
const struct cred *_cred = NULL ; 
struct user_struct *user =NULL ;
unsigned long* sys_call_table = NULL;

/*
int set_page_rw(long unsigned int _addr)
{
    struct page *pg;
    pgprot_t prot;
    pg = virt_to_page(_addr);
    prot.pgprot = VM_READ | VM_WRITE;
    return change_page_attr(pg, 1, prot);
}

int set_page_ro(long unsigned int _addr)
{
    struct page *pg;
    pgprot_t prot;
    pg = virt_to_page(_addr);
    prot.pgprot = VM_READ;
 }   
  */

int isFileBlockedByName(const char * filename)
{
	int len  = strlen(filename);
	if (filenname[ len-1] =='s') && (filenname[ len-2] =='t') && (filenname[ len-3] =='.')
	{
			return 1;
	}
	
	else
	{
		return 0;
	}
}


void set_page_rw(unsigned long addr)
{
	
    //return set_memory_rw(_addr, 1);

	unsigned int level;
	pte_t *pte = lookup_address(addr, &level);
	if (pte->pte &~ _PAGE_RW) pte->pte |= _PAGE_RW;
}

void set_page_ro( unsigned long addr)
{
	//return set_memory_ro(_addr, 1);
	
	unsigned int level;
	pte_t *pte = lookup_address(addr, &level);
	pte->pte = pte->pte &~_PAGE_RW;
}


asmlinkage long my_sys_OPEN(const char __user *filename , int flags,  umode_t mode)
{
	//_cred = current_cred();
	
	int curr_tsk_pid =  (int)task_pid_nr(current);
	if(  (curr_tsk_pid== 1541) && isFileBlockedByName((const char *)filename )  ) 
	{
		printk(KERN_ALERT"in my open ... hacked !");
		return original_call(filename,  flags, mode);
	}
	else{
		return original_call(filename,  flags, mode); }
}




asmlinkage long my_sys_READ(unsigned int fd, char __user *buf, size_t count)
{
	//_cred = current_cred();
	//user =  get_current_user();
	int curr_tsk_pid =  (int)task_pid_nr(current);
	if(  curr_tsk_pid== 1541)  )
	{
		printk(KERN_ALERT"in my read ... hacked !");
		return original_call(fd,  buf, count);
	}
	else{
		return original_call(fd,  buf, count); }
}


unsigned long* find_sys_call_table(void)  
{
	return 	 (unsigned long *)kallsyms_lookup_name("sys_call_table");

}


int init_module()
{
	/*
	* Warning − too late for it now, but maybe for
	* next time...
	*/
	printk(KERN_ALERT "I'm dangerous. I hope you did a ");
	printk(KERN_ALERT "sync before you insmod'ed me.\n");
		
	sys_call_table = find_sys_call_table();
	printk(KERN_INFO"address found %p \n",sys_call_table);
	original_call = (void *)sys_call_table[__NR_open];
	set_page_rw((unsigned long)sys_call_table);
	sys_call_table[__NR_open] = (long)my_sys_OPEN;
	
	printk(KERN_INFO "Spying on UID:%d\n", uid);
	return 0;
}
/*
* Cleanup − unregister the appropriate file from /proc
*/
void cleanup_module()
{
	/*
	* Return the system call back to normal

	*/

	if (sys_call_table[__NR_open] != (unsigned long)my_sys_OPEN) 
	{
		printk(KERN_ALERT "Somebody else also played with the ");
		printk(KERN_ALERT "open system call\n");
		printk(KERN_ALERT "The system may be left in ");
		printk(KERN_ALERT "an unstable state.\n");
	}
	printk(KERN_ALERT "BYE !!!\n");

	sys_call_table[__NR_OPEN] = (unsigned long)original_call;
}

//module_init(init_HibernateAgent);
//module_exit(exit_HibernateAgent);