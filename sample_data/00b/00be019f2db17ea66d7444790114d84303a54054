class PartitionTests3 : JUnit5Minutests {

    data class Fixture(
        val items: List<Int> = emptyList(),
        val predicates: List<(Int) -> Boolean> = emptyList()
    ) {
        fun assertResultIs(vararg expected: List<Int>) {
            assertEquals(expected.asList(), items.partition(predicates))
        }
        fun withItems(vararg items: Int) = copy(items = items.asList())
        fun withPredicates(vararg predicates: (Int) -> Boolean) = copy(predicates = predicates.asList())
    }

    override val tests = rootContext<Fixture> {
        context("no items") {
            fixture {
                Fixture()
            }
            context("no predicates") {
                test("returns empty list") {
                    assertResultIs()
                }
            }
            context("some predicates") {
                deriveFixture {
                    withPredicates(::isNegative, ::isZero, ::isPositive)
                }
                test("returns an empty list for each predicate") {
                    assertResultIs(emptyList(), emptyList(), emptyList())
                }
            }
        }

        context("some items") {
            fixture {
                Fixture(items = listOf(-1, 0, 1, 2, 3))
            }
            context("no predicates") {
                test("returns empty list") {
                    assertResultIs()
                }
            }
            context("everything matches something") {
                deriveFixture {
                    withPredicates(::isNegative, ::isZero, ::isPositive)
                }
                test("returns a list for each predicate") {
                    assertResultIs(listOf(-1), listOf(0), listOf(1, 2, 3))
                }
            }
            context("a predicate doesn't match any item") {
                deriveFixture {
                    withPredicates(::isNegative, ::isZero, ::isPositive, ::isBiggerThan10)
                }
                test("returns an empty list for that predicate") {
                    assertResultIs(listOf(-1), listOf(0), listOf(1, 2, 3), emptyList())
                }
            }
            context("an item doesn't match any predicate") {
                deriveFixture {
                    withPredicates(::isNegative, ::isPositive)
                }
                test("item is not in the returned lists") {
                    assertResultIs(listOf(-1), listOf(1, 2, 3))
                }
            }
            context("an item matches more than one predicate") {
                deriveFixture {
                    withItems(1, 2, 11)
                        .withPredicates(::isPositive, ::isBiggerThan10)
                }
                test("item is assigned to the first match predicate") {
                    assertResultIs(listOf(1, 2, 11), emptyList())
                }
            }
            context("repeated predicates") {
                deriveFixture {
                    withPredicates(::isNegative, ::isNegative, ::isZero, ::isPositive)
                }
                test("item is assigned to each predicate") {
                    assertResultIs(listOf(-1), listOf(-1), listOf(0), listOf(1, 2, 3))
                }
            }
            context("lambda predicates") {
                deriveFixture {
                    withPredicates({ x -> isNegative(x) }, { x -> isPositive(x) })
                }
                test("item is assigned to each predicate") {
                    assertResultIs(listOf(-1), listOf(1, 2, 3))
                }
            }
            context("items in a different order") {
                deriveFixture {
                    withItems(3, 2, 1, 0, -1)
                        .withPredicates(::isNegative, ::isZero, ::isPositive)
                }
                test("input order is preserved") {
                    assertResultIs(listOf(-1), listOf(0), listOf(3, 2, 1))
                }
            }
        }
    }
}

fun isBiggerThan10(x: Int) = x > 100