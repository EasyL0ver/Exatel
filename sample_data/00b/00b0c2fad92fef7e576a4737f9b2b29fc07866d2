diff --git a/src/corelib/tools/qhash.cpp b/src/corelib/tools/qhash.cpp
index d5703e8..bfc0bf3 100644
--- a/src/corelib/tools/qhash.cpp
+++ b/src/corelib/tools/qhash.cpp
@@ -166,7 +166,7 @@ static int countBits(int hint)
 const int MinNumBits = 4;
 
 const QHashData QHashData::shared_null = {
-    0, 0, Q_REFCOUNT_INITIALIZER(-1), 0, 0, MinNumBits, 0, 0, true, false, 0
+    0, 0, Q_REFCOUNT_INITIALIZER(-1), 0, 0, MinNumBits, 0, 0, 0, true, false, 0
 };
 
 void *QHashData::allocateNode(int nodeAlign)
@@ -202,6 +202,8 @@ QHashData *QHashData::detach_helper(void (*node_duplicate)(Node *, void *),
     d->userNumBits = userNumBits;
     d->numBits = numBits;
     d->numBuckets = numBuckets;
+    if (this == &QHashData::shared_null)
+        d->seed = uint(qrand());
     d->sharable = true;
     d->strictAlignment = nodeAlign > 8;
     d->reserved = 0;
diff --git a/src/corelib/tools/qhash.h b/src/corelib/tools/qhash.h
index 9e4007c..41338e2 100644
--- a/src/corelib/tools/qhash.h
+++ b/src/corelib/tools/qhash.h
@@ -123,6 +123,7 @@ struct Q_CORE_EXPORT QHashData
     short userNumBits;
     short numBits;
     int numBuckets;
+    uint seed;
     uint sharable : 1;
     uint strictAlignment : 1;
     uint reserved : 30;
@@ -481,6 +482,50 @@ private:
     static void duplicateNode(QHashData::Node *originalNode, void *newNode);
 };
 
+template<typename T> struct HasTwoArgsQHash
+{
+    typedef qint8 yes_type;
+    typedef qint64 no_type;
+
+    template<typename U, U> struct SFINAE {};
+
+    template<typename U> struct TwoArgsQHashPointer {
+        typedef uint (*qHashPtr)(U, uint);
+    };
+
+    template<typename U> static yes_type checkQHash(SFINAE<typename TwoArgsQHashPointer<U>::qHashPtr,
+                                                    static_cast<uint (*)(U, uint)>(qHash<U>) > *);
+    template<typename U> static no_type checkQHash(...);
+
+    static const bool Value = (sizeof(checkQHash<T>(0)) == sizeof(yes_type));
+};
+
+template<typename T, bool b> struct qHashChooser;
+
+template<typename T> struct qHashChooser<T, true>
+{
+    static inline uint callQHash(const T &value, uint seed)
+    {
+        return qHash(value, seed);
+    }
+};
+
+template<typename T> struct qHashChooser<T, false>
+{
+    static inline uint callQHash(const T &value, uint seed)
+    {
+        Q_UNUSED(seed);
+        return qHash(value);
+    }
+};
+
+template<typename T> struct qHashCaller
+{
+    static inline uint callQHash(const T &value, uint seed)
+    {
+        return qHashChooser<T, HasTwoArgsQHash<T>::Value>::callQHash(value, seed);
+    }
+};
 
 template <class Key, class T>
 Q_INLINE_TEMPLATE void QHash<Key, T>::deleteNode(Node *node)
@@ -859,7 +904,7 @@ Q_OUTOFLINE_TEMPLATE typename QHash<Key, T>::Node **QHash<Key, T>::findNode(cons
     uint h = 0;
 
     if (d->numBuckets || ahp) {
-        h = qHash(akey);
+        h = qHashCaller<Key>::callQHash(akey, d->seed);
         if (ahp)
             *ahp = h;
     }