Q1: Given an encoded list of size n and and index of the decoded list, find the value stored under the index.
The encoded list contains pairs of values. Every index i such that i%2 = 1 contains a value of the decoded list. Every index i such that i%2 = 0 contains a number repetitions of a value in the decoded array.

For an encoded list: [6, 4, 1, 0, 0, 7]
the decoded list will look like this: [4, 4, 4, 4, 4, 4, 0] 

Implement function find that given an encoded list and index will return the value stored under that index.

Exaples:

find([6, 4, 1, 0, 0, 7], 0) = 4
find([6, 4, 1, 0, 0, 7], 6) = 0

int find( vector<int> encoded_list, int index )
{
    int currentIndex = 0;
    for( int i = 0; i < encoded_list.size() - 1; i+2 )
    {
        if( currentIndex + encoded_list[i] -1 < index )
            currentIndex += encoded_list[i] - 1;
        return encoded_list[i+1];
    }
    return -1;
}

O(n) complexity

Q2: Given the encoded list and a indices array find all the values stored under those indices in the decoded list. Implement function findall that receives the encoded list of size n and the indices list of size k and returns the list of values from the decoded list.

Example:
findall([6,4,1,0,0,7], [3, 4, 6, 3]) = [4, 4, 0, 4]


findAll( vector<int> encoded_list, vector<int> indices )
{
    vector<pair<int,int> pairs;
    for( int i = 0; i < indices.size(); i++ )
    {
        pairs.push_back( pair( indices[i], i ) );
	}

	sort( pairs.begin(), pairs.end(), []( pair<int, int> p1, pair<int, int> p2 ) {
    	if( p1.first == p2.first )
        	return p1.second < p2.second;
    	return p1.first < p2.first;
	};

	vector<int> results;
	results.reserve( indices.size() );

	int i = 0;
	for( int k = 0; k < pairs.size(); k++ )
	{
        int currentIndex = 0;
        for( ; i < encoded_list.size() - 1; i+2 )
        {
            if( currentIndex + encoded_list[i] -1 < pairs[k].first )
                currentIndex += encoded_list[i] - 1;
            results[pairs.second] = encoded_list[i+1];
        }
        i -= 2;
        results[pairs.second] = -1;
	}

	return results;
}

O(klogk)- sorting
O(n+k)- retreiving the results
O(klogk) - final complexity