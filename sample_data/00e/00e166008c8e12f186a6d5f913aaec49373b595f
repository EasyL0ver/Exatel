-- This script has been converted to FE by iPxter


if game:GetService("RunService"):IsClient() then error("Script must be server-side in order to work; use h/ and not hl/") end
local Player,Mouse,mouse,UserInputService,ContextActionService = owner
do
	print("FE Compatibility code by Mokiros | Translated to FE by iPxter")
	script.Parent = Player.Character

	--RemoteEvent for communicating
	local Event = Instance.new("RemoteEvent")
	Event.Name = "UserInput_Event"

	--Fake event to make stuff like Mouse.KeyDown work
	local function fakeEvent()
		local t = {_fakeEvent=true,Connect=function(self,f)self.Function=f end}
		t.connect = t.Connect
		return t
	end

	--Creating fake input objects with fake variables
    local m = {Target=nil,Hit=CFrame.new(),KeyUp=fakeEvent(),KeyDown=fakeEvent(),Button1Up=fakeEvent(),Button1Down=fakeEvent()}
	local UIS = {InputBegan=fakeEvent(),InputEnded=fakeEvent()}
	local CAS = {Actions={},BindAction=function(self,name,fun,touch,...)
		CAS.Actions[name] = fun and {Name=name,Function=fun,Keys={...}} or nil
	end}
	--Merged 2 functions into one by checking amount of arguments
	CAS.UnbindAction = CAS.BindAction

	--This function will trigger the events that have been :Connect()'ed
	local function te(self,ev,...)
		local t = m[ev]
		if t and t._fakeEvent and t.Function then
			t.Function(...)
		end
	end
	m.TrigEvent = te
	UIS.TrigEvent = te

	Event.OnServerEvent:Connect(function(plr,io)
	    if plr~=Player then return end
		if io.isMouse then
			m.Target = io.Target
			m.Hit = io.Hit
		else
			local b = io.UserInputState == Enum.UserInputState.Begin
			if io.UserInputType == Enum.UserInputType.MouseButton1 then
				return m:TrigEvent(b and "Button1Down" or "Button1Up")
			end
			for _,t in pairs(CAS.Actions) do
				for _,k in pairs(t.Keys) do
					if k==io.KeyCode then
						t.Function(t.Name,io.UserInputState,io)
					end
				end
			end
			m:TrigEvent(b and "KeyDown" or "KeyUp",io.KeyCode.Name:lower())
			UIS:TrigEvent(b and "InputBegan" or "InputEnded",io,false)
	    end
	end)
	Event.Parent = NLS([==[
	local Player = game:GetService("Players").LocalPlayer
	local Event = script:WaitForChild("UserInput_Event")

	local UIS = game:GetService("UserInputService")
	local input = function(io,a)
		if a then return end
		--Since InputObject is a client-side instance, we create and pass table instead
		Event:FireServer({KeyCode=io.KeyCode,UserInputType=io.UserInputType,UserInputState=io.UserInputState})
	end
	UIS.InputBegan:Connect(input)
	UIS.InputEnded:Connect(input)

	local Mouse = Player:GetMouse()
	local h,t
	--Give the server mouse data 30 times every second, but only if the values changed
	--If player is not moving their mouse, client won't fire events
	while wait(1/30) do
		if h~=Mouse.Hit or t~=Mouse.Target then
			h,t=Mouse.Hit,Mouse.Target
			Event:FireServer({isMouse=true,Target=t,Hit=h})
		end
	end]==],Player.Character)
	Mouse,mouse,UserInputService,ContextActionService = m,m,UIS,CAS
end

spawn (function()
-------------------------------
p = game.Players.owner
char = p.Character
torso = char.Torso
hed = char.Head
neck = char.Torso.Neck
hum = char.Humanoid
hum.MaxHealth = math.huge
local msg = game:GetService("Chat")
torso.BrickColor = BrickColor.new("Brown")
hed.BrickColor = BrickColor.new("Brown")
char["Right Arm"].BrickColor = BrickColor.new("Brown")
char["Left Arm"].BrickColor = BrickColor.new("Brown")
char["Left Leg"].BrickColor = BrickColor.new("Brown") 
char["Right Leg"].BrickColor = BrickColor.new("Brown")
ypcall(function()
shirt = Instance.new("Shirt", char)
shirt.Name = "Shirt"
pants = Instance.new("Pants", char)
pants.Name = "Pants"
char.Shirt.ShirtTemplate = "rbxassetid://586567751"
char.Pants.PantsTemplate = "rbxassetid://95425972"
end)
function sbchat(msg,displayname)
        if not displayname then
            displayname = '<Bitch Smoke>'
        end
        for i,v in pairs(game:GetService('Players'):GetChildren()) do
            local st = Instance.new('StringValue')
            st.Name = 'SB_Chat'
            st.Value = displayname..'/'..msg
            delay(0.2,function() st.Parent = v end)
        end
    end
p1 = Instance.new("Part",char)
p1.FormFactor = Enum.FormFactor.Custom
p1.Size = Vector3.new(1.8,0.8,1.8)
p1.CanCollide = false
p1.Locked = true
p1.BottomSurface = Enum.SurfaceType.Smooth
p1.TopSurface = Enum.SurfaceType.Smooth
SMesh = Instance.new("SpecialMesh", p1)
SMesh.MeshId = "http://www.roblox.com/asset/?id=91673856"
SMesh.MeshType = Enum.MeshType.FileMesh
SMesh.Name = "Mesh"
SMesh.TextureId = "http://www.roblox.com/asset/?id=91673893"
w1 = Instance.new("Weld", hed)
w1.Part0 = hed
w1.C0 = CFrame.new(0,0.76,0.2)*CFrame.Angles(0.3,0,0)
w1.Part1 = p1
w1.C1 = CFrame.new(0, 0, 0)
--------------------------------
p1 = Instance.new("Part",char)
p1.FormFactor = Enum.FormFactor.Custom
p1.Size = Vector3.new(1.8,0.8,1.8)
p1.CanCollide = false
p1.Locked = true
p1.BrickColor = BrickColor.new("Really black")
p1.BottomSurface = Enum.SurfaceType.Smooth
p1.TopSurface = Enum.SurfaceType.Smooth
SMesh = Instance.new("SpecialMesh", p1)
SMesh.MeshId = "http://www.roblox.com/asset/?id=11419729"
SMesh.MeshType = Enum.MeshType.FileMesh
SMesh.Name = "Mesh"
w1 = Instance.new("Weld", hed)
w1.Part0 = hed
w1.C0 = CFrame.new(0,0.2,-0.25)
w1.Part1 = p1
w1.C1 = CFrame.new(0, 0, 0)
-----------
GroundWave3 = function()
	local HandCF = CFrame.new(torso.Position - Vector3.new(0,0,0)) * CFrame.Angles(0,0,0)
		local wave1 = Instance.new("Part", torso)
		wave1.BrickColor = BrickColor.new("Really black")
		wave1.Anchored = true
		wave1.CanCollide = false
		wave1.Locked = true
		wave1.Material = "Neon"
		wave1.Size = Vector3.new(1, 1, 1)
		wave1.TopSurface = "Smooth"
		wave1.BottomSurface = "Smooth"
		wave1.Transparency = 0
		wave1.CFrame = HandCF
		wm = Instance.new("SpecialMesh", wave1)
		wm.Scale = Vector3.new(.1,.1,.1)
		wm.MeshType = "Sphere"
		coroutine.wrap(function()
		for i = 1, 20, 1 do
		wm.Scale = Vector3.new(2 + i*2, 2 + i*2, 2 + i*2)
		--wave1.Size = wm.Scale
		wave1.CFrame = HandCF
		wave1.Transparency = i/10
		wait()
		end
		wait()
		wave1:Destroy()
	end)()
end
-------------------------------
Spawn(function()
	while wait(1) do
		GroundWave3()
		wait(.5)
		GroundWave3()
	end
end)
warn'[Ground Brake]:Connect!'
-----------------------------------
local Plr = game.Players.owner --LocalScript
	local Char = Plr.Character
	local ra = Char:FindFirstChild('Right Arm')
	local ts = Char.Torso
	local la = Char:FindFirstChild('Left Arm')
	local ll = Char:FindFirstChild('Left Leg')
	local rl = Char:FindFirstChild('Right Leg')
	local hd = Char.Head
	local root = Char:FindFirstChild('HumanoidRootPart')
	
	rarm = ra
	larm = la
	torso = ts
	hed = hd
	root = root
	lleg = ll
	rleg = rl

FloatPart = function()
	local Part = Instance.new('Part',torso)
	Part.CFrame = CFrame.new(torso.CFrame.X,workspace.Base.CFrame.Y+1,torso.CFrame.Z) * CFrame.fromEulerAnglesXYZ(86.4,0,87)
	Part.Anchored = true
	Part.Material = 'Neon'
	Part.CanCollide = false
	Part.BrickColor = BrickColor.new("Forest green")
	local Mesh = Instance.new('SpecialMesh',Part)
	Mesh.Scale = Vector3.new(4,4,.2)
	Mesh.MeshId = 'http://www.roblox.com/asset/?id=3270017'
	Mesh.VertexColor = Vector3.new(0,170,255)
	spawn(function()
		for i = 1,30 do
			Mesh.Scale = Mesh.Scale + Vector3.new(.04,.04,0)
			Part.Transparency = Part.Transparency + .035
			game["Run Service"].Stepped:wait()
		end
		Part:Destroy()
	end)
end;

DubPart = function()
	local Part = Instance.new('Part',torso)
	Part.CFrame = CFrame.new(torso.CFrame.X,workspace.Base.CFrame.Y+1,torso.CFrame.Z) * CFrame.fromEulerAnglesXYZ(86.4,0,87)
	Part.Anchored = true
	Part.CanCollide = false
	Part.Material = 'Neon'
	Part.BrickColor = BrickColor.new("Forest green")
	local Mesh = Instance.new('SpecialMesh',Part)
	Mesh.Scale = Vector3.new(7,7,.2)
	Mesh.MeshId = 'http://www.roblox.com/asset/?id=3270017'
	Mesh.VertexColor = Vector3.new(0,170,255)
	spawn(function()
		for i = 1,30 do
			Mesh.Scale = Mesh.Scale + Vector3.new(.04,.04,0)
			Part.Transparency = Part.Transparency + .035
			game["Run Service"].Stepped:wait()
		end
		Part:Destroy()
	end)
end;

OnTouch = function(Toucher)
	if Toucher.Parent.Name ~= Plr.Name and Toucher.Parent:FindFirstChild('Humanoid') then
		local Hum = Toucher.Parent:FindFirstChild('Humanoid')
		Hum.Health = Hum.Health - .7		
	end
end;

Fade = function(Item,t)
	spawn(function()
		for i = 1,20 do
			Item.Transparency = Item.Transparency + .05
			if t then
				wait(t)
			else 
				wait()
			end
		end
		Item:Destroy()
	end)
end

TouchKill = function(Toucher)
	if Toucher.Parent then
		if Toucher.Parent:FindFirstChild('Humanoid') then
			local P = Toucher.Parent:FindFirstChild('Humanoid')
			if P ~= nil and P.Parent.Name ~= Plr.Name then
				P.Health = P.Health - math.random(4,17)
			end
		end
	end
end;

Particle = function()
	local Part = Instance.new('Part',torso)
	Part.Anchored = true
	Part.Transparency = 0
	Part.Material = "Neon"
	Part.Touched:connect(function(I)OnTouch(I)end)
	Part.CanCollide = false
	Part.CFrame = torso.CFrame * CFrame.new(math.random(-10,10),math.random(-15,15),math.random(-10,10)) * CFrame.fromEulerAnglesXYZ(math.random(),math.random(),math.random())
	local Mesh = Instance.new('SpecialMesh',Part)
	Mesh.Scale = Vector3.new(1,1,1)
	Mesh.MeshId = "rbxassetid://1090700"
	Mesh.TextureId = "rbxassetid://1090703"
	spawn(function()
		for i = 1,40 do
			Part.Transparency = Part.Transparency + .0125
			Part.CFrame = Part.CFrame * CFrame.new(0,-.07,0)
			game["Run Service"].Stepped:wait()
		end
		Part:Destroy()
	end)
end;

Particle2 = function()
	local Part = Instance.new('Part',torso)
	Part.Anchored = true
	Part.Transparency = 0
	Part.Material = "Neon"
