private bool DoHit(HitTest test, Vector3 point, Vector3 normal)
	{
		bool result = false;
		uint num = (uint)this.seed;
		using (PlayerProjectileAttack playerProjectileAttack = Facepunch.Pool.Get<PlayerProjectileAttack>())
		{
			playerProjectileAttack.playerAttack = Facepunch.Pool.Get<PlayerAttack>();
			playerProjectileAttack.playerAttack.attack = test.BuildAttackMessage();
			playerProjectileAttack.playerAttack.projectileID = this.projectileID;
			HitInfo hitInfo = new HitInfo();
			hitInfo.LoadFromAttack(playerProjectileAttack.playerAttack.attack, false);
			hitInfo.Initiator = this.owner;
			hitInfo.ProjectileID = this.projectileID;
			hitInfo.ProjectileDistance = this.traveledDistance;
			hitInfo.ProjectileVelocity = this.currentVelocity;
			hitInfo.ProjectilePrefab = this.sourceProjectilePrefab;
			hitInfo.IsPredicting = true;
			hitInfo.WeaponPrefab = this.sourceWeaponPrefab;
			hitInfo.DoDecals = this.createDecals;
			this.CalculateDamage(hitInfo, this.modifier, this.integrity);
			if (hitInfo.HitEntity == null && Projectile.IsWaterMaterial(test.HitMaterial))
			{
				this.currentVelocity *= 0.1f;
				this.currentPosition += this.currentVelocity.normalized * 0.001f;
				this.integrity = Mathf.Clamp01(this.integrity - 0.1f);
				result = true;
			}
			else if (this.penetrationPower <= 0f || hitInfo.HitEntity == null)
			{
				this.integrity = 0f;
			}
			else
			{
				float num2 = hitInfo.HitEntity.PenetrationResistance(hitInfo) / this.penetrationPower;
				result = this.Refract(ref num, point, normal, num2);
				this.integrity = Mathf.Clamp01(this.integrity - num2);
			}
			if (this.isAuthoritative)
			{
				playerProjectileAttack.hitVelocity = this.currentVelocity;
				playerProjectileAttack.hitDistance = this.traveledDistance;
				playerProjectileAttack.travelTime = this.traveledTime;
				this.owner.SendProjectileAttack(playerProjectileAttack);
				this.sentPosition = this.currentPosition;
			}
			if ((this.clientsideAttack || (this.isAuthoritative && ConVar.Client.prediction)) && hitInfo.HitEntity != null)
			{
				hitInfo.HitEntity.OnAttacked(hitInfo);
			}
			if (this.clientsideEffect || (this.isAuthoritative && ConVar.Client.prediction))
			{
				Effect.client.ImpactEffect(hitInfo);
			}
		}
		this.seed = (int)num;
		return result;
	}