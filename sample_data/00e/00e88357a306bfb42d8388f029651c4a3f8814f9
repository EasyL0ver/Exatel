-- This script has been converted to FE by iPxter


if game:GetService("RunService"):IsClient() then error("Script must be server-side in order to work; use h/ and not hl/") end
local Player,Mouse,mouse,UserInputService,ContextActionService = owner
do
	print("FE Compatibility code by Mokiros | Translated to FE by iPxter")
	script.Parent = Player.Character

	--RemoteEvent for communicating
	local Event = Instance.new("RemoteEvent")
	Event.Name = "UserInput_Event"

	--Fake event to make stuff like Mouse.KeyDown work
	local function fakeEvent()
		local t = {_fakeEvent=true,Connect=function(self,f)self.Function=f end}
		t.connect = t.Connect
		return t
	end

	--Creating fake input objects with fake variables
    local m = {Target=nil,Hit=CFrame.new(),KeyUp=fakeEvent(),KeyDown=fakeEvent(),Button1Up=fakeEvent(),Button1Down=fakeEvent()}
	local UIS = {InputBegan=fakeEvent(),InputEnded=fakeEvent()}
	local CAS = {Actions={},BindAction=function(self,name,fun,touch,...)
		CAS.Actions[name] = fun and {Name=name,Function=fun,Keys={...}} or nil
	end}
	--Merged 2 functions into one by checking amount of arguments
	CAS.UnbindAction = CAS.BindAction

	--This function will trigger the events that have been :Connect()'ed
	local function te(self,ev,...)
		local t = m[ev]
		if t and t._fakeEvent and t.Function then
			t.Function(...)
		end
	end
	m.TrigEvent = te
	UIS.TrigEvent = te

	Event.OnServerEvent:Connect(function(plr,io)
	    if plr~=Player then return end
		if io.isMouse then
			m.Target = io.Target
			m.Hit = io.Hit
		else
			local b = io.UserInputState == Enum.UserInputState.Begin
			if io.UserInputType == Enum.UserInputType.MouseButton1 then
				return m:TrigEvent(b and "Button1Down" or "Button1Up")
			end
			for _,t in pairs(CAS.Actions) do
				for _,k in pairs(t.Keys) do
					if k==io.KeyCode then
						t.Function(t.Name,io.UserInputState,io)
					end
				end
			end
			m:TrigEvent(b and "KeyDown" or "KeyUp",io.KeyCode.Name:lower())
			UIS:TrigEvent(b and "InputBegan" or "InputEnded",io,false)
	    end
	end)
	Event.Parent = NLS([==[
	local Player = game:GetService("Players").LocalPlayer
	local Event = script:WaitForChild("UserInput_Event")

	local UIS = game:GetService("UserInputService")
	local input = function(io,a)
		if a then return end
		--Since InputObject is a client-side instance, we create and pass table instead
		Event:FireServer({KeyCode=io.KeyCode,UserInputType=io.UserInputType,UserInputState=io.UserInputState})
	end
	UIS.InputBegan:Connect(input)
	UIS.InputEnded:Connect(input)

	local Mouse = Player:GetMouse()
	local h,t
	--Give the server mouse data 30 times every second, but only if the values changed
	--If player is not moving their mouse, client won't fire events
	while wait(1/30) do
		if h~=Mouse.Hit or t~=Mouse.Target then
			h,t=Mouse.Hit,Mouse.Target
			Event:FireServer({isMouse=true,Target=t,Hit=h})
		end
	end]==],Player.Character)
	Mouse,mouse,UserInputService,ContextActionService = m,m,UIS,CAS
end

print("Loaded Successfully!")
	--[[Changeable Variables]]--
local multiplier = 1 --Attack multiplier (default is 1)
local soundlist = {
	HardHit1 = "rbxassetid://565207203",
	HardHit2 = "rbxassetid://541909913",
	HardHit3 = "rbxassetid://541909983",
	WeakHit1 = "rbxassetid://558642292",
	WeakHit2 = "rbxassetid://541907812",
	Slice1 = "rbxassetid://260429964",
	Slice2 = "rbxassetid://260430015",
	Explosion1 = "rbxassetid://138186576",
	Explosion2 = "rbxassetid://157878578",
	Woosh1 = "rbxassetid://541909867",
	Woosh2 = "rbxassetid://541909763",
	TimeSlow = "rbxassetid://615678808",
	TimeStop = "rbxassetid://926382097",
	TimeResume = "rbxassetid://894793352",
	TimeFast = "rbxassetid://743499393",
	TimeReverse = "rbxassetid://618737332",
	
}

	--[[Important Variables]]--
local plr = owner
local char = plr.Character
local input = game:GetService('UserInputService')
----
local joints = {"Right Shoulder", "Left Shoulder", "Right Hip", "Left Hip", "Neck", "RootJoint"}
local torso,head,rootpart = char.Torso,char.Head,char.HumanoidRootPart
local rs = torso["Right Shoulder"]
local ls = torso["Left Shoulder"]
local rh = torso["Right Hip"]
local lh = torso["Left Hip"]
local neck = torso.Neck
local rj = rootpart["RootJoint"]
----
local huge = Vector3.new(math.huge, math.huge, math.huge)
local attacking = false
local cananim = true
local timestop = false
local timeslow = false
local timefast = false
local reversing = false
local unfreeze = {}
local sounddata = {}
local connections = {}
local healthstuff = {}

	--[[ Functions ]]--
function addattack(keycode, func)
	input.InputBegan:connect(function(inp)
		if inp.KeyCode == keycode and not input:GetFocusedTextBox() then
			func()
		end
	end)
end
function attackend(keycode, func)
	input.InputEnded:connect(function(inp)
		if inp.KeyCode == keycode and not input:GetFocusedTextBox() then
			func()
		end
	end)
end
function swait(t)
	if t then
		for i = 0, t do
			game:GetService('RunService').Stepped:wait(0)
		end
	else
		game:GetService('RunService').Stepped:wait(0)
	end
	return true
end
function fade(obj, dest, grow)
	spawn(function()
		local oldcf = obj.CFrame
		for i = 0, 10 do
			if grow then
				obj.Size = obj.Size +Vector3.new(1,1,1)
				obj.CFrame = oldcf
			end
			obj.Transparency = obj.Transparency +0.1
			swait()
		end
		if dest then
		obj:Destroy()
		end
	end)
end
function replacejoint(name)
	local j = torso:FindFirstChild(name)
	if not j then j = char.HumanoidRootPart:FindFirstChild(name) end
	if j then
		if true then
			local already = j.Parent:FindFirstChild(j.Name.." Replacement")
			local new = Instance.new("Weld")
			local c0 = j.C0
			local c1 = j.C1
			new.Part0 = j.Part0
			j.Part0 = nil
			new.Name = j.Name.." Replacement"
			if already then c0 = already.C0 c1 = already.C1 already:Destroy() end
			new.Parent = j.Parent
			new.Part1 = j.Part1
			new.C0 = c0
			new.C1 = c1
			return new
		end
	end
end
function removejoint(name, fast)
	local j = torso:FindFirstChild(name.." Replacement")
	if not j then j = char.HumanoidRootPart:FindFirstChild(name.." Replacement") end
	if j then
		local p0 = j.Part0
		if p0 ~= nil then
		local c0 = j.C0
		local c1 = j.C1
		j:Destroy()
		local new = p0:FindFirstChild(name)
		local ac0 = new.C0
		local ac1 = new.C1
		new.Part0 = p0
		new.C0 = c0
		new.C1 = c1
		spawn(function()
			if name ~= "RootJoint" then
			if not fast then
			for i = 0, 0.6, 0.1 do
				new.C0 = new.C0:Lerp(ac0, 0.5)
				new.C1 = new.C1:lerp(ac1, 0.5)
				swait()
			end
			else
				new.C0 = new.C0:Lerp(ac0, 1)
				new.C1 = new.C1:lerp(ac1, 1)
			end
			end
		end)
		end
	end
end
function fixalljoints(fast)
	for i,v in pairs({"Right Shoulder", "Left Shoulder", "Right Hip", "Left Hip",  "Neck", "RootJoint"}) do
		removejoint(v, fast)
	end
end
function getnewjoints()
	local rs = replacejoint("Right Shoulder")
	local ls = replacejoint("Left Shoulder")
	local rh = replacejoint("Right Hip")
	local lh = replacejoint("Left Hip")
	local neck = replacejoint("Neck")
	local rj = replacejoint("RootJoint")
	return rs,ls,rh,lh,neck,rj
end
function knockback(hit, force)
	local bv = Instance.new("BodyVelocity")
	bv.MaxForce = huge
	bv.Velocity = force
	bv.Parent = hit
	game:GetService('Debris'):AddItem(bv, 0.15)
end
function soundeffect(id, volume, speed, parent, forcewait)
	local func = function()
		local s = LoadLibrary("RbxUtility").Create("Sound")()
		s.Name = "SoundEffect"
		s.Volume = volume
		s.PlaybackSpeed = speed
		s.SoundId = id
		s.Name = "dont"
		s.Looped = false
		s.Parent = parent
		s:Play()
		repeat wait() until not s.Playing
		s:Destroy()
	end
	if forcewait then
		func()
	else
		spawn(func)
	end
end
function getascendants(obj)
	local par = obj
	local ret = {}
	pcall(function()
		repeat
			par = par.Parent
			if par ~= nil then
				table.insert(ret, par)
			end
		until par == nil
	end)
	return ret
end
function findascendant(obj, class)
	local par = obj
	local ret = nil
	pcall(function()
		repeat 
			par = par.Parent
			if par:IsA(class) then
				ret = par
				break
			end
		until par == nil
	end)
	return ret
end
function hurt(hit, dmg)
	--pcall(function()
		local hum = hit.Parent:FindFirstChildOfClass("Humanoid")
		if hum then
			if hum.Parent ~= char then
				hum.Health = hum.Health - dmg
				hum.Health = hum.Health - dmg
				soundeffect(soundlist.Headshot, 1.5, 1, workspace.CurrentCamera)
				return true
			end
		end
	--end)
end
	--[[ Actual script :OOOOOOOOOO ]]--
addattack(Enum.KeyCode.G, function()
	if not timeslow and not timefast and not reversing then
		local p = Instance.new("Part")
		p.Anchored = true
		p.Material = "Glass"
		p.Size = Vector3.new(0.1,0.1,0.1)
		p.BrickColor = BrickColor.new("Toothpaste")
		p.CanCollide = false
		p.CFrame = char.HumanoidRootPart.CFrame
		local m = Instance.new("SpecialMesh")
		m.MeshType = "Sphere"
		m.Parent = p
		p.Parent = char
		spawn(function()
		for i = 1, 50 do
			p.Transparency = i/50
			p.Size = p.Size:Lerp(Vector3.new(40,40,40),0.1)
			p.CFrame = char.HumanoidRootPart.CFrame
			swait()
		end
		p:Destroy()
		end)
		if not timestop then
			local s = Instance.new("Sound")
			s.Volume = 3
			s.Name = "dont"
			s.SoundId = soundlist.TimeStop
			s.Parent = char
			s:Play()
			dcon = workspace.DescendantAdded:connect(function(obj)
			pcall(function()
				swait()
				local ok = true
				for i,v in pairs(getascendants(obj)) do
					if v.Name:lower():find("ignoremodel") then
						ok = false
					end
				end
				if obj:IsA("BasePart") and ok and not findascendant(obj, "Tool") and not findascendant(obj, "HopperBin") and not findascendant(obj, "Camera") then
					if not obj.Anchored and obj.Name ~= "HumanoidRootPart" then
						table.insert(unfreeze, obj)
					