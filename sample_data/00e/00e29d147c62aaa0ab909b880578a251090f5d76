#include <math.h>
#include <iostream>
using namespace std;
class C
{
public:
       double re, im;
double abs() const { return sqrt(re*re+im*im); }
C()
{
         re=0;
         im=0;
}
C(double re, double im) 
{
         this->re = re;
         this->im = im;
}
C(double re) 
{
         this->re = re;
         this->im = 0;
}
C& operator *(const double b) const 
{
         return * new C(this->re*b, this->im*b);
}
C& operator +(const double b) const 
{
         return * new C(this->re+b, this->im);
}
C& operator -(const double b) const 
{
         return * new C(this->re-b, this->im);
}
C& operator /(const C& b) const 
{
         double d = b.re*b.re+b.im*b.im;
         return * new C((this->re*b.re+this->im*b.im)/(d),
         (this->im*b.re-this->re*b.im)/(d));
}
};
C operator+ (C a, const C &b)
{
         a.re=a.re+b.re;
         a.im=a.im+b.im;
         return a;
}
C operator- (C a, const C &b)
{
         a.re=a.re-b.re;
         a.im=a.im-b.im;
         return a;
}
C operator* (C a, const C &b)
{
	C aa;
         aa.re=a.re*b.re-a.im*b.im;
         aa.im=a.im*b.re+a.re*b.im;
         return aa;
}
C& operator *(const double& a, const C& b) 
{
         C & r = b*a;
         return r;
}
C& operator +(const double& a, const C& b) 
{
         C & r = b+a;
         return r;
}
C& operator -(const double& a, const C& b) 
{
         C & r = b-a;
         return r;
}	
C& operator /(const double& a, const C& b) 
{
         C & aa = * new C(a,0);
         C & r = aa/b;
         return r;
}
C& operator /(const C& b, const double& a) 
{
         C & aa = * new C(a,0);
         C & r = b/aa;
         return r;
}
bool operator == (const C& a , const C& b)
{
	return ((a.re==b.re)&&(a.im==b.im));
}
bool operator != (const C& a , const C& b)
{
	return ((a.re!=b.re)or(a.im!=b.im));
}

ostream& operator<< (ostream& ont, const C& z){
         std::cout << z.re << z.im << std::endl;
         return ont;}
#include<complex_main.h>