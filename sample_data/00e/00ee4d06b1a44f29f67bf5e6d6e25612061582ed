package ct.af.utils;

import com.google.gson.*;
import com.google.gson.reflect.TypeToken;

import ct.af.enums.ECType;
import ct.af.enums.EConfig;
import ct.af.resourcemodel.*;
import ec02.af.abstracts.AbstractAF;
import ec02.af.utils.AFLog;
import org.apache.commons.lang3.StringUtils;
import org.joda.time.format.DateTimeFormat;
import org.joda.time.format.DateTimeFormatter;
import java.io.BufferedReader;
import java.lang.reflect.Type;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.*;


public class Config {

	private static boolean hasReloadConfig = true;

	private static String libVersion;
	private static String pgzServerName;
	private static String userSysList;
	private static String protocol;
	private static List<String> urlList = new ArrayList<>();
	private static int defaultServerTimeout;


	private static Map<String, ResourceMaster> resourceMasterHashMap = new HashMap<>();
	private static Map<String, ResourceRollback> resourceRollbackHashMap = new HashMap<>();
	private static Map<String, ResourceInventory> resourceInventoryHashMap = new HashMap<>();
	private static Map<String, ResourceRuleMaster> resourceRuleHashMap = new HashMap<>();
	private static Map<String, ResourceNeTypeProperty> resourceNeTypePropertyHashMap = new HashMap<>();
	private static Map<String, ResourceMappingCommand> resourceMappingCommandHashMap = new HashMap<>();
	private static Map<String, ResourceProperty> resourcePropertyHashMap = new HashMap<>();
	private static Map<String, List<ResourceErrorHandling>> resourceErrorhandlingHashMap = new HashMap<>();
	private static Map<String, DropResourceOrderType> dropResourceOrderTypeHashMap = new HashMap<>();
	private static Map<String, Map<String, String>> overwriteDefHashMap = new HashMap<>();
	private static Map<String, Map<String, Object>> overwriteParamHashMap = new HashMap<>();
	private static Map<String, String> serverInterfaceHashMap = new HashMap<>();
	private static Map<String, String> urlServersToClientHashMap = new HashMap<>();
	private static Map<String, Integer> serversTimeoutHashMap = new HashMap<>();


	private static final DateTimeFormatter formatDateWithMiTz = DateTimeFormat.forPattern("yyyyMMdd HH:mm:ss.SSSZ"); //System logic
	private static final DateTimeFormatter journeyDateFormat = DateTimeFormat.forPattern("yyyyMMddHHmmssZ");
	private static final DateTimeFormatter journeyDateTask =  DateTimeFormat.forPattern("yyyy-MM-dd HH:mm:ss:SSSZ");
	private static final DateTimeFormatter hrzDateFormat = DateTimeFormat.forPattern("yyyy-MM-dd HH:mm:ssZ");
	private static final DateTimeFormatter requestIdDate = DateTimeFormat.forPattern("yyyyMMddHHmmss");


	private static String sdfInfranodeInterface;
	private static String sdfInventoryInterface;
	private static String sdfJourneyInterface;
	private static String mongoInterface;
	private static String sdfReservequotaInterface;
	private static String sdfReleasequotaInterface;
	private static String sdfCommitquotaInterface;
	private static String mdInterface;
	private static String recoveryFile;


	private static String urlSdfInventory;
	private static String urlSdfInfranode;
	private static String urlSdfJourney;
	private static String urlSdfReservequota;
	private static String urlSdfReleasequota;
	private static String urlSdfCommitquota;
	private static String urlMongo;
	private static String actor;



	private static int sdfInventoryTimeout;
	private static int sdfInfranodeTimeout;
	private static int sdfJourneyTimeout;
	private static int sdfReservequotaTimeout;
	private static int sdfReleasequotaTimeout;
	private static int sdfCommitquotaTimeout;
	private static int mongoTimeout;
	private static int mdTimeout;
	private static double gapExectime;


	private static String provisioningUrl;
	private static String healthCheckUrl;
	private static int expirationDate;
	private static int sdfMaxRetry;
	private static int requestMaxActive;
	private static int requestCount = 0;
	private static String appName;
	private static String edrLog;
	private static String cdrLog;
	private static String transactionLog;
	private static String incomingUnknownLog;
	private static String pathEs22RecoverylogDuplicate;
	private static String pathEs22RecoverylogTimeout;
	private static String pathEs22RecoverylogError;
	private static String pathBackupResourceInventory;
	private static String pathFileBackupResourceInventory;

	private static Map<String, ResourceSearchKeyNode> resourceIndexMap = new HashMap<>();
	private static Map<String, List<ResourceNeIdRouting>> resourceNeIdRoutingMap = new HashMap<>();
	private static boolean isRandomInvoke = true;
	private static boolean enableMaxActive = true;
	private static boolean resourceInventoryFromFileMode;

	private Config() {
		throw new IllegalStateException("Utility class");
	}

	public static boolean verifyConfig(AbstractAF abstractAF) {

		for (EConfig conf : EConfig.values()) {
			String confName = conf.getName().trim();
			if (!abstractAF.getEquinoxUtils().getHmWarmConfig().containsKey(confName)) {
				AFLog.e("Configuration named : " + confName + " [ NOT FOUND ], please check EC02 config !");
				AFLog.e("Verify Config Failed!!");
				return false;
			}
		}

		hasReloadConfig = true;

		Config.loadConfig(abstractAF);
		initialRandomInvoke(abstractAF);

		List<String> valueUserSysList = Arrays.asList(userSysList.split("\\|"));
		for(String usersys:valueUserSysList){
			if(StringUtils.isBlank(usersys)){
				AFLog.w("Warning! Found some empty in userSysList");
				continue;
			}
			usersys = usersys.trim();
			String usrResourceName = "Resource-Name-"+usersys;
			String valueServersInterface =getWarmConfig(abstractAF,usrResourceName);
			if(StringUtils.isBlank(valueServersInterface)){
				AFLog.w("Warning! cannot found "+usrResourceName+" for UserSys="+usersys+", it's required for asynchronus.");
			}
			valueServersInterface = valueServersInterface.trim();

			serverInterfaceHashMap.put(usersys, valueServersInterface);
			String urlServersToClient = getWarmConfig(abstractAF,"URL-"+usersys);
			if(StringUtils.isBlank(urlServersToClient)){
				AFLog.w("Warning! "+"No url for "+usersys.trim());
			}
			urlServersToClient= urlServersToClient.trim();

			urlServersToClientHashMap.put(usersys, urlServersToClient);


			int serversTimeout;
			try{
				serversTimeout =  Integer.parseInt(getWarmConfig(abstractAF, "Tm-"+usersys));
				serversTimeoutHashMap.put(usersys, serversTimeout);
			}catch (NumberFormatException e) {
				AFLog.w("Warning! "+"No time out for "+usersys);
			}

		}			

		Collections.addAll(urlList, provisioningUrl.split("\\|"));
		if (urlList.isEmpty()) {
			AFLog.e("Verify Config Failed!! " + "Provisioning-URL can't be empty");
			return false;
		}
		
		if(healthCheckUrl==null){
			healthCheckUrl = "";
		}else if(healthCheckUrl.contains("\\|")){			
			healthCheckUrl = healthCheckUrl.split("\\|")[0];
			AFLog.w("Warning! url for health check is only '"+healthCheckUrl+"'");
		}

		if (!initializeResourcePropertyHashMap(abstractAF)) {
			AFLog.e("Load Resource Property Failed");
			return false;
		}

		if (!initializeResourceRollbackHashMap(abstractAF)) {
			AFLog.e("Load Resource Rollback Failed");
			return false;
		}

		if (!initializeResourceSearchKeyHashmap(abstractAF)) {
			AFLog.e("Load Resource SearchKey Failed");
			return false;
		}

		if (!initializeResourceMasterHashMap(abstractAF)) {
			AFLog.e("Load Resource Master Failed");
			return false;
		}

		if (!initializeResourceNeIdRouting(abstractAF)) {
			AFLog.e("Load Resource NeId Routing Failed");
			return false;
		}

		if (!initializeOverwriteDefHashMap(abstractAF)) {
			AFLog.e("Load Overwrite Def Failed");
			return false;
		}

		if (!initializeResourceRuleHashMap(abstractAF)) {
			AFLog.e("Load Resource Rule Failed");
			return false;
		}


		if (!initializeResourceNeTypeProperty(abstractAF)){
			AFLog.e("Load Resource NeType Property Failed");
			return false;
		}

		if (!initializeResourceMappingCommandHashMap(abstractAF)) {
			AFLog.e("Load Resource Mapping Failed");
			return false;
		}

		if (!initializeResourceErrorHandlingHashMap(abstractAF)) {
			AFLog.e("Load Resource Error Handling Failed");
			return false;
		}

		if (!initializeDropResourceOrderTypeHashMap(abstractAF)) {
			AFLog.e("Load Drop Resource OrderType Failed");
			return false;
		}

		try{
			if(Integer.parseInt(getWarmConfig(abstractAF, "MaxActive_Request")) < 1){
				AFLog.e("Verify Config Failed! MaxActive_Request is less than 0.");
				return false;
			}
		}catch (NumberFormatException e) {
			AFLog.e("Verify Config Failed! MaxActive_Request cannot be parseInt.");
			return false;
		}

		if (!initialMaxActive(abstractAF)) {
			AFLog.e("Fail Config  EnableMaxActive");
			return false;
		}
		if(Config.resourceInventoryFromFileMode &&!initalResourceInventoryFormFileName(abstractAF))
		{
			AFLog.e("ResourceInventory File not found!");
			return false;
		}
		if(!initalResourceInventoryFormFileMode(abstractAF))
		{
			AFLog.e("ResourceInventory Mode error not match :" + Config.getWarmConfig(abstractAF, EConfig.RESOURCEINVENTORYFORMFILEMODE.getName()) );
			return false;
		}

		if(Config.resourceInventoryFromFileMode &&!initalJsonFormatFileResourceInventory()) {
			AFLog.e("ResourceInventory File invalidJSON");
			return false;
		}

		AFLog.i("Verify Config Success!!");
		AFLog.i("Lib Version : " + libVersion);

		return true;		
	}

	public static String getLibraryConfig(AbstractAF abstractAF) {
		Map<String, Map<String, String>> coldConfigList = abstractAF.getEquinoxUtils().getHmColdConfig();
		Map<String, String> libAttribute = coldConfigList.get("Library");
		return libAttribute.get("name");
	}

	public static String