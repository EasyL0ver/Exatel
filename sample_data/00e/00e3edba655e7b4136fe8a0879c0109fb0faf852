var cfg = require('../../../../../../../config.json');
var AStar = require('./astar.js');
var util = require('./util.js');

function getNeighbours(cy,cx,grid) {
  for(var y = -2;y <= 2; y++) {
    for(var x = -2;x <= 2;x++) {
      if(!(Math.abs(y) == 2 && Math.abs(x) == 2)) {
        if(typeof grid[cy+y] !== "undefined" && typeof grid[cy+y][cx+x] !== 'undefined') {
          grid[cy+y][cx+x] = 1;
        }
      }
    }
  }
  return grid;
}

var overlays = {

  buildOverlay:null,
  fogOfWar:null,
  cache:{},

  updateBuildOverlay: function(game) {

    if(game.input.id != null) {

      //toggle overlay for walls
      if(game.state.p.f[game.input.id].type == 'wall') { 
        this.buildOverlay = this.buildGrid();
        //add all possibilites
        var e = game.state.e.length;
        while(e--) {
          if((game.state.e[e].et == 'w' || game.state.e[e].et == 'b') && game.state.e[e].p == game.state.p.pid) {
            this.buildOverlay = getNeighbours(game.state.e[e].y,game.state.e[e].x,this.buildOverlay);
          }
        }

        //remove all tiles with entities
        this.buildOverlay[cfg.gridymax][0] = 0;
        this.buildOverlay[0][cfg.gridxmax] = 0;
        var e = game.state.e.length;
        while(e--) {
          if(game.state.e[e].et == 'm') {
            if(1-(game.state.e[e].m-game.state.t)/game.state.e[e].tps <= 0.45) {
              this.buildOverlay[game.state.e[e].y][game.state.e[e].x] = 0;
            }
            if(1-(game.state.e[e].m-game.state.t)/game.state.e[e].tps >= 0.55) {
              this.buildOverlay[game.state.e[e].ty][game.state.e[e].tx] = 0;
            }
          } else {
            this.buildOverlay[game.state.e[e].y][game.state.e[e].x] = 0;
          }
        }

        //remove path
        var pathgrid = this.buildWallGrid(game);
        //check if there'd be a valid path left
        for (var y in this.buildOverlay){
          for (var x in this.buildOverlay[y] ) {
            if(this.buildOverlay[y][x] == 1) {
              //don't build on the only path left
              pathgrid[y][x] = 1;
              var testpath = AStar(pathgrid,[0,cfg.gridymax],[cfg.gridxmax,0]);
              if(!testpath.length) {
                this.buildOverlay[y][x] = 0;
              }
              pathgrid[y][x] = 0;
            }
          }
        }

      }

      //draw overlay for towers
      if(typeof game.state.p.f[game.input.id].entity_id !== "undefined") {
        this.buildOverlay = this.buildWallGrid(game);
        //move mode
        if(game.state.p.f[game.input.id].entity_id > 0) {
          var tower = game.getEntityById(game.state.p.f[game.input.id].entity_id);
          if(tower != false) {
            for (var y in this.buildOverlay){
              for (var x in this.buildOverlay[y] ) {
                if(this.buildOverlay[y][x] == 1) {
                  if(Math.abs(y-tower.y) > 2 || Math.abs(x-tower.x) > 2 || (Math.abs(y-tower.y) == 2 && Math.abs(x-tower.x) == 2)) {
                    this.buildOverlay[y][x] = 0;
                  }
                }
              }
            }
          }
        }
        //remove all standing towers from grid
        var e = game.state.e.length;
        while(e--) {
          if(game.state.e[e].et == 't' || (game.state.e[e].et == 'w' && game.state.e[e].p != game.state.p.pid)) {
            this.buildOverlay[game.state.e[e].y][game.state.e[e].x] = 0;
          }
        }
      }

    }
  },

  drawBuildOverlay: function(game){
    //draw the overlay
    for (var y in this.buildOverlay){
      for (var x in this.buildOverlay[y] ) {
        if(this.buildOverlay[y][x] == 1) {
          this.drawOverlayTile(x,y,game.state.p.pid);
        }
      }
    }
  },

  drawOverlayTile: function(x,y,p) {
    //set cache if this is the first draw
    if(typeof this.cache["overlaytile"+p] === 'undefined') {
      this.cacheOverlayTile(p);
    }
    ctx.drawImage(this.cache["overlaytile"+p],x*cfg.ts,y*cfg.ts);
  },

  cacheOverlayTile: function(p) {
    this.cache["overlaytile"+p] = document.createElement('canvas');
    this.cache["overlaytile"+p].width = cfg.ts;
    this.cache["overlaytile"+p].height = cfg.ts;
    var octx = this.cache["overlaytile"+p].getContext("2d");
    octx.fillStyle = game.color(p,0.3);
    octx.strokeStyle = game.color(p,0.3);
    octx.lineWidth = 4;
    util.rectagon(0,0,octx);
    octx.fill();
    octx.stroke();
  },

  updateFogOfWar: function(game) {
    this.fogOfWar = this.buildGrid();
    var e = game.state.e.length;
    while(e--) {
      if(game.state.e[e].p == game.state.p.pid) {
        for(var y = -2;y <= 2; y++) {
          for(var x = -2;x <= 2;x++) {
            if(!(Math.abs(x) == 2 && Math.abs(y) == 2)) {
              if(typeof this.fogOfWar[game.state.e[e].y+y] !== "undefined" && typeof this.fogOfWar[game.state.e[e].y+y][game.state.e[e].x+x] !== 'undefined') {
                this.fogOfWar[game.state.e[e].y+y][game.state.e[e].x+x] = 1;  
              }
            }
          }
        }
      }
    }
  },

  drawFogOfWar: function(r) {
    //draw the fog of war
    if(this.fogOfWar !== null) {
      var y = this.fogOfWar.length;
      while(y--) {
        var x = this.fogOfWar[y].length;
        while(x--) {
          if(!this.fogOfWar[y][x]) {
            if(!(y == 0 && x == cfg.gridxmax) && !(x == 0 && y == cfg.gridymax)) {
              this.drawFogTile(x,y);
            }
          }
        }
      }
    }
  },

  drawFogTile: function(x,y) {
    //set cache if this is the first draw
    if(typeof this.cache["fogtile"] === 'undefined') {
      this.cacheFogTile();
    }
    ctx.drawImage(this.cache["fogtile"],x*cfg.ts,y*cfg.ts);
  },

  cacheFogTile: function() {
    this.cache["fogtile"] = document.createElement('canvas');
    this.cache["fogtile"].width = cfg.ts;
    this.cache["fogtile"].height = cfg.ts;
    var octx = this.cache["fogtile"].getContext("2d");
    util.rectagon(0,0,octx);
    octx.fillStyle = "rgb(26,26,26)";
    octx.fill();
  },

  buildGrid: function() {
    var grid = [[]];
    for(var y = 0;y <= cfg.gridymax;y++) {
      grid[y] = [];
      for(var x = 0;x <= cfg.gridxmax;x++) {
        grid[y][x] = 0;
      }
    }
    return grid;
  },

  buildWallGrid: function(game) {
    var grid = [[]];
    for(var y = 0;y <= cfg.gridymax;y++) {
      grid[y] = [];
      for(var x = 0;x <= cfg.gridxmax;x++) {
        grid[y][x] = 0;
      }
    }
    var e = game.state.e.length;
    while(e--) {
      if(game.state.e[e].et == 'w') {
        grid[game.state.e[e].y][game.state.e[e].x] = 1;
      }
    }
    return grid;
  },

};

module.exports = exports = overlays;