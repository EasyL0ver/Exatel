using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
using System.Threading;

namespace ExNet.Security
{
    public struct Tbuid : IComparable<Tbuid>, IEquatable<Tbuid>
    {
        private static int _increment = 0x0000000;

        public static int UniqueId = Process.GetCurrentProcess().Id;

        public int UniqueKey { get; private set; }
        public long Timestamp { get; private set; }
        public int Increment { get; private set; }

        public static Tbuid NewTbuid()
        {

            Tbuid tbd = new Tbuid();
            tbd.UniqueKey = UniqueId;
            tbd.Timestamp = DateTime.Now.Ticks;
            tbd.Increment = Interlocked.Increment(ref _increment);
            return tbd;

        }

        public static Tbuid NewTbuid(int uniqueKey)
        {

            Tbuid tbd = new Tbuid();
            tbd.UniqueKey = uniqueKey;
            tbd.Timestamp = DateTime.Now.Ticks;
            tbd.Increment = Interlocked.Increment(ref _increment);
            return tbd;

        }

        private static byte[] FromHex(string value)
        {
            if (string.IsNullOrEmpty(value)) throw new ArgumentNullException(nameof(value));
            if (value.Length != 32) throw new ArgumentException($"Tbuid strings should be 32 hex characters, got {value.Length} : \"{value}\"");

            var bytes = new byte[16];

            for (var i = 0; i < 32; i += 2)
            {
                bytes[i / 2] = Convert.ToByte(value.Substring(i, 2), 16);
            }

            return bytes;
        }

        public Tbuid(byte[] source)
        {
            UniqueKey = BitConverter.ToInt32(source, 0);
            Timestamp = BitConverter.ToInt64(source, 4);
            Increment = BitConverter.ToInt32(source, 12);
        }

        public Tbuid(string source) : this(FromHex(source))
        {
        }


        public byte[] ToByteArray()
        {
            byte[] bytes = new byte[16];
            Buffer.BlockCopy(BitConverter.GetBytes(UniqueKey), 0, bytes, 0, 4);
            Buffer.BlockCopy(BitConverter.GetBytes(Timestamp), 0, bytes, 4, 8);
            Buffer.BlockCopy(BitConverter.GetBytes(Increment), 0, bytes, 12, 4);
            return bytes;

        }




        public override string ToString()
        {
            //return this.ToByteArray().ToHex();
            return BitConverter.ToString(this.ToByteArray()).Replace("-", "").ToLower();
        }

        public bool Equals(Tbuid other)
        {
            return this.UniqueKey == other.UniqueKey &&
                   this.Timestamp == other.Timestamp &&
                   this.Increment == other.Increment;
        }

        public override bool Equals(object other)
        {
            return Equals(other is Tbuid);
        }

        public int CompareTo(Tbuid other)
        {
            var timeComparison = Timestamp.CompareTo(other.Timestamp);
            if (timeComparison != 0) return timeComparison;
            return Increment.CompareTo(other.Increment);
        }

        public override int GetHashCode()
        {
            int hash = UniqueKey;
            unchecked
            {
                hash += Timestamp.GetHashCode();
                hash += Increment.GetHashCode();
            }
            return hash;
        }


        #region Operators

        public static bool operator ==(Tbuid lhs, Tbuid rhs)
        {
            return lhs.Equals(rhs);
        }

        public static bool operator !=(Tbuid lhs, Tbuid rhs)
        {
            return !(lhs == rhs);
        }

        public static bool operator >=(Tbuid lhs, Tbuid rhs)
        {
            return lhs.CompareTo(rhs) >= 0;
        }

        public static bool operator >(Tbuid lhs, Tbuid rhs)
        {
            return lhs.CompareTo(rhs) > 0;
        }

        public static bool operator <(Tbuid lhs, Tbuid rhs)
        {
            return lhs.CompareTo(rhs) < 0;
        }

        public static bool operator <=(Tbuid lhs, Tbuid rhs)
        {
            return lhs.CompareTo(rhs) <= 0;
        }

        #endregion
    }
}