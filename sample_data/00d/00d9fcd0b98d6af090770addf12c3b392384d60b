--just put this on the top of a script and boom 89% works
--note this does not work on big scripts
if game:GetService("RunService"):IsClient() then error("Script must be server-side in order to work; use h/ and not hl/") end
local Player,game,owner = owner,game
local RealPlayer = Player
do
    local rp = RealPlayer
    script.Parent = rp.Character
   
    --RemoteEvent for communicating
    local Event = Instance.new("RemoteEvent")
    Event.Name = "UserInput_Event"
 
    --Fake event to make stuff like Mouse.KeyDown work
    local function fakeEvent()
        local t = {_fakeEvent=true,Functions={},Connect=function(self,f)table.insert(self.Functions,f) end}
        t.connect = t.Connect
        return t
    end
 
    --Creating fake input objects with fake variables
    local m = {Target=nil,Hit=CFrame.new(),KeyUp=fakeEvent(),KeyDown=fakeEvent(),Button1Up=fakeEvent(),Button1Down=fakeEvent()}
    local UIS = {InputBegan=fakeEvent(),InputEnded=fakeEvent()}
    local CAS = {Actions={},BindAction=function(self,name,fun,touch,...)
        CAS.Actions[name] = fun and {Name=name,Function=fun,Keys={...}} or nil
    end}
    --Merged 2 functions into one by checking amount of arguments
    CAS.UnbindAction = CAS.BindAction
 
    --This function will trigger the events that have been :Connect()'ed
    local function te(self,ev,...)
        local t = m[ev]
        if t and t._fakeEvent then
            for _,f in pairs(t.Functions) do
                f(...)
            end
        end
    end
    m.TrigEvent = te
    UIS.TrigEvent = te
 
    Event.OnServerEvent:Connect(function(plr,io)
        if plr~=rp then return end
        m.Target = io.Target
        m.Hit = io.Hit
        if not io.isMouse then
            local b = io.UserInputState == Enum.UserInputState.Begin
            if io.UserInputType == Enum.UserInputType.MouseButton1 then
                return m:TrigEvent(b and "Button1Down" or "Button1Up")
            end
            for _,t in pairs(CAS.Actions) do
                for _,k in pairs(t.Keys) do
                    if k==io.KeyCode then
                        t.Function(t.Name,io.UserInputState,io)
                    end
                end
            end
            m:TrigEvent(b and "KeyDown" or "KeyUp",io.KeyCode.Name:lower())
            UIS:TrigEvent(b and "InputBegan" or "InputEnded",io,false)
        end
    end)
    Event.Parent = NLS([==[
    local Player = game:GetService("Players").LocalPlayer
    local Event = script:WaitForChild("UserInput_Event")
 
    local Mouse = Player:GetMouse()
    local UIS = game:GetService("UserInputService")
    local input = function(io,a)
        if a then return end
        --Since InputObject is a client-side instance, we create and pass table instead
        Event:FireServer({KeyCode=io.KeyCode,UserInputType=io.UserInputType,UserInputState=io.UserInputState,Hit=Mouse.Hit,Target=Mouse.Target})
    end
    UIS.InputBegan:Connect(input)
    UIS.InputEnded:Connect(input)
 
    local h,t
    --Give the server mouse data 30 times every second, but only if the values changed
    --If player is not moving their mouse, client won't fire events
    while wait(1/30) do
        if h~=Mouse.Hit or t~=Mouse.Target then
            h,t=Mouse.Hit,Mouse.Target
            Event:FireServer({isMouse=true,Target=t,Hit=h})
        end
    end]==],Player.Character)
 
    ----Sandboxed game object that allows the usage of client-side methods and services
    --Real game object
    local _rg = game
 
    --Metatable for fake service
    local fsmt = {
        __index = function(self,k)
            local s = rawget(self,"_RealService")
            if s then return s[k] end
        end,
        __newindex = function(self,k,v)
            local s = rawget(self,"_RealService")
            if s then s[k]=v end
        end,
        __call = function(self,...)
            local s = rawget(self,"_RealService")
            if s then return s(...) end
        end
    }
    local function FakeService(t,RealService)
        t._RealService = typeof(RealService)=="string" and _rg:GetService(RealService) or RealService
        return setmetatable(t,fsmt)
    end
 
    --Fake game object
    local g = {
        GetService = function(self,s)
            return self[s]
        end,
        Players = FakeService({
            LocalPlayer = FakeService({GetMouse=function(self)return m end},Player)
        },"Players"),
        UserInputService = FakeService(UIS,"UserInputService"),
        ContextActionService = FakeService(CAS,"ContextActionService"),
    }
    rawset(g.Players,"localPlayer",g.Players.LocalPlayer)
    g.service = g.GetService
   
    g.RunService = FakeService({
        RenderStepped = _rg:GetService("RunService").Heartbeat,
        BindToRenderStep = function(self,name,_,fun)
            self._btrs[name] = self.Heartbeat:Connect(fun)
        end,
        UnbindFromRenderStep = function(self,name)
            self._btrs[name]:Disconnect()
        end,
    },"RunService")
 
    setmetatable(g,{
        __index=function(self,s)
            return _rg:GetService(s) or typeof(_rg[s])=="function"
            and function(_,...)return _rg[s](_rg,...)end or _rg[s]
        end,
        __newindex = fsmt.__newindex,
        __call = fsmt.__call
    })
    --Changing owner to fake player object to support owner:GetMouse()
    game,owner = g,g.Players.LocalPlayer
end
 



warn('Script by stommmDev haha now u cant copy my scripts :D')

local plr = game.Players.LocalPlayer
repeat wait(.2) until plr.Character
local char = plr.Character
if char:FindFirstChild("Animate") then
	char.Animate:Destroy()
end
local runsrv = game:GetService("RunService")
local progs = 0
char:WaitForChild("Torso")
local armR = char.Torso["Right Shoulder"]
local armL = char.Torso["Left Shoulder"]
local legR = char.Torso["Right Hip"]
local legL = char.Torso["Left Hip"]
local human = char.Humanoid
human.Name = "ScriptbyStommmDev"
local walking = false
for i,v in pairs(human:GetPlayingAnimationTracks()) do
	v:Stop()
end
local root = char:WaitForChild("HumanoidRootPart").RootJoint
local jumpposeaL = armL.C0 * CFrame.Angles(-1.8,0,0) * CFrame.new(0,-.5,-.4)
local jumpposeaR = armR.C0 * CFrame.Angles(-1.8,0,0) * CFrame.new(0,-.5,-.4)
local oldarmR = armR.C0
local oldarmL = armL.C0
local jumpposeroot = root.C0 * CFrame.Angles(.2,0,0)
local oldroot = root.C0
local oldlegR = legR.C0
local oldlegL = legL.C0
local legpos1R = legR.C0 * CFrame.Angles(0,0,.5)
local legpos1L = legL.C0 * CFrame.Angles(0,0,.5)
local legpos2R = legR.C0 * CFrame.Angles(0,0,-.5)
local legpos2L = legL.C0 * CFrame.Angles(0,0,-.5)
local animeatR = armR.C0 * CFrame.Angles(.2,.8,2)
local armpos1R = armR.C0 * CFrame.Angles(0,0,-.7) 
local armpos1L = armL.C0 * CFrame.Angles(0,0,-.7) 
local armpos2R = armR.C0 * CFrame.Angles(0,0,.7) 
local armpos2L = armL.C0 * CFrame.Angles(0,0,.7)
if char:FindFirstChild("Bighead") then else
	print("oh no bighead rip ur ass xdxdxdxdxdx")
	 animeatR = armR.C0 * CFrame.Angles(.2,.8,2) * CFrame.new(-.4,0,0)
end
local eating = false
local jumping = false
human.Running:Connect(function(speed)
	if speed > 2 then
	walking = true
	else
		
		walking = false
	end
end)
human.Jumping:Connect(function()
	jumping = true
	for i=1,15 do
	
		armL.C0 = armL.C0:Lerp(jumpposeaL,.025)
		armR.C0 = armR.C0:Lerp(jumpposeaR,.025)
		root.C0 = root.C0:Lerp(jumpposeroot,.025)
		runsrv.RenderStepped:wait()
	end
	wait(.05)
for i=1,15 do
		
		
		armL.C0 = armL.C0:Lerp(jumpposeaL * CFrame.Angles(0,0,1),.045)
		armR.C0 = armR.C0:Lerp(jumpposeaR * CFrame.Angles(0,0,-1),.045)
		root.C0 = root.C0:Lerp(jumpposeroot,.045)
		
		runsrv.RenderStepped:wait()
		
	end	
	
	for i=1,25 do
		armL.C0 = armL.C0:Lerp(oldarmL,.075)
		armR.C0 = armR.C0:Lerp(oldarmR,.075)
		root.C0 = root.C0:Lerp(oldroot,.075)
		runsrv.RenderStepped:wait()
	end
	jumping = false
end)

local finpr = false

function onchatted2(message)
		if char.Head:FindFirstChild("Message") then
		char.Head:FindFirstChild("Message"):Destroy()
	end
	local messagebill = Instance.new("BillboardGui")
messagebill.Size = UDim2.new(0,200,0,100)
messagebill.Parent = plr.Character.Head
messagebill.StudsOffset = Vector3.new(0,4,0)
messagebill.Name = "Message"
local chattext = Instance.new("TextLabel")
chattext.Parent = messagebill
chattext.Size = UDim2.new(1,0,1,0)
chattext.BackgroundTransparency = 1
chattext.TextColor3 = Color3.new(255,255,255)
chattext.TextScaled =  false
local length = string.len(message)
chattext.Text = ""
chattext.TextSize = 18
for i = 1, length do
				wait(.034)
				local subText = string.sub(message, 1, i)
				
				chattext.Text = subText
end
	
wait(3)
if messagebill then
	for i = length,1,-1 do
		wait(.034)
		local subText = string.sub(message, 1, i)
				
				chattext.Text = subText
	end
	wait(.034)
	messagebill:Destroy()
end

end

runsrv.RenderStepped:connect(function()
	
	
	
human.MaxHealth =  1e5555555
		human.Health = 1e5555555
	if char:FindFirstChild("Ass") then else
		local force = Instance.new("ForceField",char)
		force.Name = "Ass"
	     force.Visible = false
	end
	if char:FindFirstChild("ScriptbyStommmDev") then else
		local hum = Instance.new("Humanoid",char)
		hum.MaxHealth =  1e5555555
		hum.Health = 1e5555555
		hum.Name = "ScriptbyStommmDev"
		human = hum
	end	
	
	
	
	
	
	if finpr == false then
		if walking == true then
		finpr = true
		progs = progs + 1
		--print(progs)
		wait(.15)
		finpr = false
		else
			progs = 0
			for i = 1,25 do
				legR.C0 = legR.C0:Lerp(oldlegR,.075)
					legL.C0 = legL.C0:Lerp(oldlegL,.075)
					if jumping == false then
					if eating == false then
						armR.C0 = armR.C0:Lerp(oldarmR,.080)
					end
					armL.C0 = armL.C0:Lerp(oldarmL,.080)
					end
			