rom Objects.HitBtc import HitBtc
import time

tail = []
response = {}

def run():
    print(123)
    while True:
        try:
            if len(tail) > 0:
                for i in range(95):
                    func = tail.pop()
                    response.update({id(func) : func()})
                time.sleep(1)
        except IndexError:
            pass
        except Exception as e:
            print(e)


class Api():

def __init__(self , api_key=None , api_secret=None):
    self.key = api_key
    self.secret = api_secret

    self.public = self.Public(self)
    self.user = self.User(self)

def execute(self , func):
    tail.append(func)
    while True:
        if response.get(id(func)) != None:
            return response.get(id(func))

####################################################################################################################
class Public(HitBtc.Public):

    def __init__(self , api = None) -> None:
        self.api = api


    def get_symbol(self , symbol_code=''):
        return self.api.execute(
            lambda: HitBtc(api_key=self.api.key ,
                           api_secret=self.api.secret).Public.get_symbol(symbol_code=symbol_code))

    def get_ticker(self , symbol=''):
        return self.api.execute(lambda : HitBtc(api_key=self.api.key ,
                                                api_secret=self.api.secret).Public.get_ticker(symbol))

    def get_trades(self , symbol , sort='DESC' , by='timestamp' , limit='100'):
        return self.api.execute(
            lambda : HitBtc(api_key=self.api.key ,
                            api_secret=self.api.secret).Public.get_trades(symbol , sort , by , limit))

    def get_orderbook(self , symbol , limit=100):
        return self.api.execute(lambda : HitBtc(api_key=self.api.key ,
                                                api_secret=self.api.secret).Public.get_orderbook(symbol , limit))

    def get_candles(self , symbol , limit=100 , period='M30'):
        return self.api.execute(
            lambda : HitBtc(api_key=self.api.key ,
                            api_secret=self.api.secret).Public.get_candles(symbol , limit , period))

    def get_currencies(self):
        return self.api.execute(lambda : HitBtc(api_key=self.api.key ,
                                                api_secret=self.api.secret).Public.get_currencies())

class User(HitBtc.User):

    def __init__(self , api=None) -> None:
        self.api = api
        self.orders = self.Orders(api)

    def get_trading_balance(self , ):
        return self.api.execute(lambda: HitBtc(api_key=self.api.key ,
                                               api_secret=self.api.secret).User.get_trading_balance())

    def get_balance(self , ):
        return self.api.execute(lambda : HitBtc(api_key=self.api.key ,
                                                api_secret=self.api.secret).User.get_balance())


    class Orders(HitBtc.User.Orders):
        def __init__(self , api = None) -> None:
            self.api = api

        def get_active_order(self , symbol=''):
            return self.api.execute(lambda : HitBtc(api_key=self.api.key , api_secret=self.api.secret).
                                 User.Orders.get_active_order(symbol))

        def get_order(self , symbol='' , fromm='' , till='' , limit=100 , clientOrderId=''):
            return self.api.execute(lambda : HitBtc(api_key=self.api.key , api_secret=self.api.secret).
                                 User.Orders.get_order(symbol , fromm , till , limit , clientOrderId))

        def new_order(self , symbol , quantity , side , price , stopPrice='' , strictValidate=False , expireTime='' ,
                      type='limit' , timeInForce='GTC' , clientOrderId=''):

            return self.api.execute(lambda : HitBtc(api_key=self.api.key , api_secret=self.api.secret).
                                 User.Orders.new_order(symbol , quantity , side , price , stopPrice ,
                                                       strictValidate , expireTime , type ,
                                                       timeInForce , clientOrderId))
        def cancel_order(self , clientOrderId):
            return self.api.execute(lambda : HitBtc(api_key=self.api.key , api_secret=self.api.secret).User.
                                 Orders.cancel_order(clientOrderId))
	
threading.Thread(target=run, daemon=True).start() 
threading.Thread(target=Thread_Creator.creator , daemon=True).start()