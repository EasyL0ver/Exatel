 @r = rand(@Frame * chf("seed"));
v[]@phistory;

function vector go_towards(vector @from, @to){
    if(@to.x < @from.x){
        @from.x -= 1;
    }
    if(@to.x > @from.x){
        @from.x += 1;
    }
    if(@to.y < @from.y){
        @from.y -= 1;
    }
    if(@to.y > @from.y){
        @from.y += 1;
    }
    if(@to.z < @from.z){
        @from.z -= 1;
    }
    if(@to.z > @from.z){
        @from.z += 1;
    }

    return @from;
}

function vector go_random(@P, @phistory){
    @seed = fit(@r,0,1,-1,1);

    if(@seed > 0.5 && @seed < 1){
        @P.x += 1;
    }
    if(@seed > 0 && @seed < 0.5){
        @P.x -= 1;
    }
    if(@seed > -0.5 && @seed < 0){
        @P.z += 1;
    }
    if(@seed > -1 && @seed < -0.5){
        @P.z -= 1;
    }

    foreach(vector @pos; @phistory) {
        if(@P == @pos)
        {
            if(@r < 0.333) {
                @P.y += 1; 
            }else if (@r > 0.666){
                @P.y -= 1;
            }
        }
    }

    return @P;
}

function vector go_home(vector @P){
    vector @o = @phistory[0];

    f@dist = distance(@P, @o);

    if(@dist > 50.0) { 
        @dist = 50.0; 
    }

    // If the distance is lower than snap, guarantee to go towards the origin
    float @snap = 2.0; 

    float @thresh = (@dist/100.0) - (@snap/100.0);

    // If biased, make the point go towards the origin
    if(@r > @thresh){
        @P = go_towards(@P, @o);
    } else{
        @P = go_random(@P, @seed, @phistory);
    }
}

if(@Frame > 100){
    @P = go_home(@P);
}else{
    @P = go_random(@P, @seed, @phistory);
}

push(@phistory, @P);