class FilePermission
  include Mongoid::Document
  include Mongoid::Timestamps::Short
  include Mongoid::Enum

  #Callbacks
  before_update :update_permission
  before_create :add_permission

  after_destroy :destroy_permission
  after_create :trigger_resource_rearrange
  after_update :trigger_resource_rearrange

  embedded_in :directory
  embedded_in :static_file
  belongs_to :user
  belongs_to :access_role
  scope :only_user_permissions, -> {where(:user_id.nin => ["", nil])}
  scope :only_access_role_permissions, -> {where(:access_role_id.nin => ["", nil])}
  scope :deleted, -> {where(deleted: true)}
  scope :not_deleted, -> {where(deleted: false)}
  scope :inherted, -> {where(inherted: true)}
  scope :overwritten, -> {where(overwritten: true)}
  scope :not_inherted, -> {where(inherted: false)}
  scope :not_overwritten, -> {where(overwritten: false)}
  enum :access_type, [:read_only, :write]
  field :i, as: :inherted, default: false, type: Boolean
  field :d, as: :deleted, default: false, type: Boolean
  field :o, as: :overwritten, default: false, type: Boolean
  field :ch, as: :was_changed, type: Boolean, default: true

  # HERE IS POSSIBILITY of self triggering callbacks

  private

  def destroy_permission
    file = self._parent
    parent = file.is_a?(Directory) ? 'parent' : 'directory'
    parent_directory_permission = file.send(parent).file_permissions.not_deleted.find_by(user: self.user, access_role: self.access_role)
    FilePermission.skip_callback(:create, :before, :add_permission)
    FilePermission.skip_callback(:create, :after, :trigger_resource_rearrange)
    file.file_permissions.create(user: self.user, access_role: self.access_role, access_type: self.access_type, inherted: self.inherted, deleted: true) if parent_directory_permission.present?
    FilePermission.set_callback(:create, :before, :add_permission)
    FilePermission.set_callback(:create, :after, :trigger_resource_rearrange)
    trigger_resource_rearrange
  end

  def add_permission
    parent = self._parent
    parent.file_permissions.each do |pp|
      pp.delete if pp.user == self.user and pp.access_role == self.access_role and pp.deleted?
    end
  end

  def update_permission
    self.inherted = false
    self.overwritten = false
    self.changed = true
    true
  end

  def trigger_resource_rearrange
    parent = self._parent
    parent.save
  end

end