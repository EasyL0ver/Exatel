/*****************************************************************************/
/*  Copyright 1993 National Instruments Corporatation. All rights reserved.  */
/*****************************************************************************/

#include <utility.h>
#include <gpib.h>
#include <formatio.h>
#include "hp34401a.h"

/* = Hewlett-Packard 34401A Multimeter (GPIB) ============================== */
/*  LabWindows 2.0 Instrument Driver                                         */
/*  Original Release: October, 1992                                          */
/*  By: National Instruments, Inc.                                           */
/*      Author - Haihua Gong                                                 */
/*  Originally written in C                                                  */
/*  Modification History:                                                    */
/*           Add     range checking for range variable in conf() function.   */
/*                   range checking for intgrat_time, aper_time, trig_delay, */
/*                   trig_cnt, band_width, db_ref, dbm_ref, security_code,   */
/*                   new_cal_code, stamp, message.                           */
/*           Adjust  function order                                          */
/*                                                                           */
/* Modified by:          Haiwa Gong, National Instruments, Austin, Texas     */
/*                                                                           */
/* Modification:         Changed the GPIB Library calls so that they check   */
/*                       for the error bit being set to indicate an error    */
/*                       (& 0x8000) instead of checking for a negative       */
/*                       return value.                                       */
/*                                                                           */
/* Modification Date:    April 20, 1994                                      */
/*                                                                           */
/* Modified by:          Jeff Orbach, National Instruments, Austin, Texas    */
/*                       Phone (800) 433-3488  Fax (512) 794-5794            */
/*                                                                           */
/* ========================================================================= */
/* = DEFINE STATEMENTS ===================================================== */
#define MAX_CMD_LENGTH  10000

/* = UTILITY ROUTINES ====================================================== */
int hp34401a_open_instr (int, int *);
int hp34401a_close_instr (int);
int hp34401a_invalid_integer_range (int, int, int, int);
int hp34401a_invalid_long_range (long, long, long, int);
int hp34401a_invalid_double_range (double, double, double, int);
int hp34401a_device_closed (int);
int hp34401a_read_msg (int, char *, int);
int hp34401a_write_msg (int, char *, int);
int hp34401a_check_instr_status (int);
int hp34401a_clear (int);
int hp34401a_loc_remote (int, int);
int hp34401a_timeout (int, int);
int hp34401a_string_to_int (char *[], int, int, char *, int *);
void hp34401a_setup_arrays (void);

/* = INSTRUMENT TABLE ====================================================== */
/*  address array: contains the GPIB addresses of opened instruments.        */
/*  bd array: contains the device descriptors returned by OpenDev.           */
/*  instr_cnt: contains the number of instruments open of this model type.   */
/* ========================================================================= */
static int  address[hp34401a_MAX_INSTR + 1];
static int  bd[hp34401a_MAX_INSTR + 1];
static int instr_cnt;
static int hp34401a_err;
/* = STATIC VARIABLES ====================================================== */
/*  cmd is a buffer for GPIB I/O strings                                     */
/* ========================================================================= */
static char  cmd[10000];
/* = INSTRUMENT-DEPENDENT COMMAND ARRAYS =================================== */
/*  See bottom of this file for array initialization.                        */
/* ========================================================================= */
static char *func_str[11];
static char *func2_str[9];
static char *resol_str[3];
static char *resol_mode_str[2];
static char *math_op_str[5];
static char *trig_srce_str[3];
static char *terminals_str[2];
static char *auto_zero_str[3];
static char *auto_imped_str[2];
static char *beeper_state[2];
static double  fun_low_range[9];
static double  fun_high_range[9];

/* ========================================================================= */
int hp34401a_init (addr, instrID)
int addr;
int *instrID;
{
    int id;

    if (hp34401a_invalid_integer_range (addr, 0, 30,  -1) != 0)
        return hp34401a_err;
    /*  Initialize entry in Instrument Table and interface for instrument.  */
    if (hp34401a_open_instr (addr, &id) != 0)
        return hp34401a_err;
    /*  Perform an Identification Query on the instrument.  */
    if (hp34401a_write_msg (id, "*IDN?", 5) != 0)  {
        hp34401a_close_instr (id);
        return hp34401a_err;
    }
    if (hp34401a_read_msg (id, cmd, MAX_CMD_LENGTH) != 0)  {
        hp34401a_close_instr (id);
        return hp34401a_err;
    }
    /*  Check to see if the ID query returns the correct response.  */
    if (CompareBytes (cmd, 0, "HEWLETT-PACKARD,34401A", 0, 22, 0) != 0)  {
        hp34401a_err = 223;
        hp34401a_close_instr (id);
        return hp34401a_err;
    }
    /*  Initialize the instrument to a known state.  */
    if (hp34401a_write_msg (id, "*CLS\r\n", 6) != 0)  {
        hp34401a_close_instr (id);
        return hp34401a_err;
    }
    /*  Initialize Instrument-Dependent Command arrays.  */
    hp34401a_setup_arrays ();
    /*  Set timeout to 10 seconds  */
    hp34401a_timeout (id, 13);
    /*  Check the Status Byte of the instrument for proper execution.  */
    if (hp34401a_check_instr_status (id) != 0)
        return hp34401a_err;
    *instrID = id;
    return hp34401a_err;
}

/* ========================================================================= */
int hp34401a_conf (instrID, func, autorange, range, resol)
int instrID;
int func;
int autorange;
double range;
int resol;
{

    if (hp34401a_invalid_integer_range (instrID, 1, hp34401a_MAX_INSTR,  -1) != 0)
        return hp34401a_err;
    if (hp34401a_invalid_integer_range (func, 0, 10,  -2) != 0)
        return hp34401a_err;
    if (hp34401a_invalid_integer_range (autorange, 0, 1,  -3) != 0)
        return hp34401a_err;
    if (func < 9 && func != 2)
        if (hp34401a_invalid_double_range (range, fun_low_range[func], fun_high_range[func],  -4) != 0)
            return hp34401a_err;
    if (hp34401a_invalid_integer_range (resol, 0, 2,  -5) != 0)
        return hp34401a_err;
    if (hp34401a_device_closed (instrID) != 0)
        return hp34401a_err;
    /*  Configure the test  */
    if (func == 9 || func == 10)  {
        Fmt (cmd, "%s<:CONF:%s\r\n", func_str[func]);
        if (hp34401a_write_msg (instrID, cmd, NumFmtdBytes ()) != 0)
            return hp34401a_err;
    }
    else  {
        /*  Configure the measurement  */
        if (autorange == 1)
            Fmt (cmd, "%s<:CONF:%s AUTO,%s\r\n", func_str[func], resol_str[resol]);
        else
            Fmt (cmd, "%s<:CONF:%s %f,%s\r\n", func_str[func], range, resol_str[resol]);
        if (hp34401a_write_msg (instrID, cmd, NumFmtdBytes ()) != 0)
            return hp34401a_err;
    }
    /*  Check the Status Byte of the instrument for proper execution.  */
    if (hp34401a_check_instr_status (instrID) != 0)
        return hp34401a_err;
    return hp34401a_err;
}

/* ========================================================================= */
int hp34401a_conf_trig (instrID, trig_srce, auto_delay, trig_delay, trig_cnt, samp_cnt)
int instrID;
int trig_srce;
int auto_delay;
double trig_delay;
long trig_cnt;
long samp_cnt;
{

    if (hp34401a_invalid_integer_range (instrID, 1, hp34401a_MAX_INSTR,  -1) != 0)
        return hp34401a_err;
    if (hp34401a_invalid_integer_range (trig_srce, 0, 2,  -2) != 0)
        return hp34401a_err;
    if (hp34401a_invalid_integer_range (auto_delay, 0, 1,  -3) != 0)
        return hp34401a_err;
    if (hp34401a_invalid_double_range (trig_delay, 0.0, 3600.0,  -4) != 0)
        return hp34401a_err;
    if (hp34401a_invalid_long_range (trig_cnt, 1L, 50000L,  -5) != 0)
        return hp34401a_err;
    if (hp34401a_invalid_long_range (samp_cnt, 1L, 50000L,  -6) != 0)
        return hp34401a_err;
    if (hp34401a_device_closed (instrID) != 0)
        return hp34401a_err;
    if (!auto_delay)
        /*  Auto-delay off  */
        Fmt (cmd, "%s<:TRIG:SOUR %s;DEL %f;COUN %d[b4];:SAMP:COUN %d[b4]\r\n", trig_srce_str[trig_srce], trig_delay,
        trig_cnt, samp_cnt);
    else
        Fmt (cmd, "%s<:TRIG:SOUR %s;COUN %d[b4];DEL:AUTO ON;:SAMP:COUN %d[b4]\r\n", trig_srce_str[trig_srce], trig_cnt,
        samp_cnt);
    if (hp34401a_write_msg (instrID, cmd, NumFmtdBytes ()) != 0)
        return hp34401a_err;
    /*  Check the Status Byte of the instrument for proper execution.  */
    if (hp34401a_check_instr_status (instrID) != 0)
        return hp34401a_err;
    return hp34401a_err;
}

/* ========================================================================= */
int hp34401a_conf_integrat_time (instrID, func, integrat_time)
int instrID;
int func;
double integrat_time;
{

    if (hp34401a_invalid_integer_range (instrID, 1, hp34401a_MAX_INSTR,  -1) != 0)
        return hp34401a_err;
    if (func != 1 && func != 4 && func != 5 && func != 6)  {
        hp34401a_err =  -2;
        return hp34401a_err;
    }
    if (hp34401a_invalid_double_range