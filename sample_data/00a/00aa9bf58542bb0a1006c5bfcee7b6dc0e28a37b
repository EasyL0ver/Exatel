import java.awt.Color;
import java.awt.Component;
import java.awt.Container;
import java.awt.Graphics;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.lang.reflect.InvocationTargetException;
import java.text.DecimalFormat;
import java.text.NumberFormat;
import java.util.ArrayList;

import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JFrame;
import javax.swing.JTabbedPane;
import javax.swing.SwingUtilities;

import com.rarebot.event.listeners.PaintListener;
import com.rarebot.script.Script;
import com.rarebot.script.ScriptManifest;
import com.rarebot.script.methods.Skills;
import com.rarebot.script.util.SkillData;
import com.rarebot.script.util.Timer;
import com.rarebot.script.wrappers.RSNPC;
import com.rarebot.script.wrappers.RSObject;
import com.rarebot.script.wrappers.RSTile;

@ScriptManifest(authors = {"TheBat"}, 
		keywords = {"Runecrafting"}, 
		name = "BatRuneSpan",
		description = "Trains RC in the RuneSpan",
		version = 1.0)

		public class BatRuneSpan extends Script implements PaintListener{
	public static double version = 1.0;
	private NumberFormat k = new DecimalFormat("###,###,###");
	public Timer runTime = new Timer(0);
	public SkillData info;
	public Long START_TIME;
	public int[] SKILLS_ARRAY = new int[25];
	private String status = "Starting up";
	private RSTile START_TILE;
	private int maxNode = 70471;
	private ArrayList<String> monsterNames = new ArrayList<String>();
	private ArrayList<String> allMonsters = new ArrayList<String>();

	private GUI gui;

	public boolean onStart() {

		try {
			SwingUtilities.invokeAndWait(new Runnable() {
				@Override
				public void run() {
					gui = new GUI();
					gui.setVisible(true);
				}
			});
		} catch (InterruptedException ex) {
		} catch (InvocationTargetException ex) {
		}
		while(gui.isVisible()){
			sleep(100);
		}
		getSkillData();
		START_TIME = System.currentTimeMillis();
		START_TILE = getMyPlayer().getLocation();
		info = skills.getSkillDataInstance();
		setMaxNode();
		status = "Searching for Nodes";
		return true;
	}
	public int loop() {
		if(status.equals("Siphoning Node")){
			if(getMyPlayer().getAnimation() != 16596)status = "Searching for Nodes";
			return 100;
		}

		if(status.equals("Searching for Nodes")){
			for(int i = 70455; i <= maxNode; i++){
				try{
					RSObject node = objects.getNearest(i);
					if(calc.distanceBetween(START_TILE, node.getLocation()) <= 10){
						node.interact("Siphon");
						sleep(1000);
						while(getMyPlayer().isMoving()){
							sleep(200);
						}
						status = "Siphoning Node";
						return 100;
					}
				}catch(NullPointerException np){}
			}
			status = "Searching for Monsters";
			return 100;
		}

		if(status.equals("Searching for Monsters")){
			for(String name:monsterNames){
				try{
					RSNPC monster = npcs.getNearest(name);
					int dyingAni = 0;
					if(name.contains("essling"))dyingAni = 16661;
					if(name.contains("esshound"))dyingAni = 16571;
					if(name.contains("esswraith"))dyingAni = 16641;

					if(monster.getAnimation() != dyingAni && calc.distanceBetween(START_TILE, monster.getLocation()) <= 10){
						monster.interact("Siphon");
						sleep(1000);
						while(getMyPlayer().isMoving()){
							sleep(200);
						}
						status = "Siphoning Monster";
						return 100;
					}
				}catch(NullPointerException np){}
			}
			return 100;
		}
		if(status.equals("Siphoning Monster")){			
			for(int i = 70455; i <= maxNode; i++){
				if(getMyPlayer().getAnimation() != 16596){
					status = "Searching for Nodes";
					return 100;
				}
				try{
					RSObject node = objects.getNearest(i);
					if(calc.distanceBetween(START_TILE, node.getLocation()) <= 10){
						node.interact("Siphon");
						sleep(1000);
						while(getMyPlayer().isMoving()){
							sleep(200);
						}
						status = "Siphoning Node";
						return 100;
					}
				}catch(NullPointerException np){}
			}
			return 100;
		}
		return 100;
	}
	public void onRepaint(Graphics grphcs) {        
		grphcs.setColor(Color.BLACK);
		grphcs.fill3DRect(0, 340, 515, 140, true);
		grphcs.setColor(Color.WHITE);

		grphcs.setColor(Color.WHITE);
		grphcs.drawLine(0, (int) mouse.getLocation().getY(), game.getWidth(), (int) mouse.getLocation().getY());
		grphcs.drawLine((int) mouse.getLocation().getX(), 0, (int) mouse.getLocation().getX(), game.getHeight());
		int idx = 358;
		grphcs.drawString("Runtime: " + runTime.toElapsedString(), 5, idx+=20);
		grphcs.drawString("Status: " + status, 5, idx+=20);

		for(int curskill = 0; curskill < Skills.SKILL_NAMES.length; curskill++) {
			if(info.expGain(curskill) == 0) continue;
			grphcs.drawString(Skills.SKILL_NAMES[curskill] + " lvl: " + skills.getRealLevel(curskill) + " (" + levelsGained(curskill) +
					")  |   XP: " + k.format(info.expGain(curskill)) + "  |   XP/H: " + k.format(info.hourlyExp(curskill))
					+ "  |   TTL: " + timeTillLvl(curskill), 10, idx+=20);
		}
	}

	public int levelsGained(final int idx) {
		return skills.getRealLevel(idx) - Skills.getLevelAt(info.getStartExp()[idx]);
	}
	public void getSkillData() {
		for (int counter = 0; counter <= 24; counter++) {
			SKILLS_ARRAY[counter] = skills.getCurrentExp(counter);
		}
	}
	public String timeTillLvl(final int idx) {
		return Timer.format(skills.getTimeTillNextLevel(idx, info.getStartExp()[idx], runTime.getElapsed()));
	}

	private void setMaxNode() {
		int RCLevel = info.level(20);
		if(RCLevel <= 1) maxNode = 70456;
		if(RCLevel <= 5) maxNode = 70457;
		if(RCLevel <= 9) maxNode = 70458;
		if(RCLevel <= 14) maxNode = 70459;
		if(RCLevel <= 17) maxNode = 70460;
		if(RCLevel <= 20) maxNode = 70461;
		if(RCLevel <= 27) maxNode = 70462;
		if(RCLevel <= 35) maxNode = 70463;
		if(RCLevel <= 40) maxNode = 70464;
		if(RCLevel <= 44) maxNode = 70465;
		if(RCLevel <= 54) maxNode = 70466;
		if(RCLevel <= 65) maxNode = 70467;
		if(RCLevel <= 77) maxNode = 70468;
		if(RCLevel <= 83) maxNode = 70469;
		if(RCLevel <= 90) maxNode = 70470;
		if(RCLevel <= 95) maxNode = 70471;
	}

	class GUI extends JFrame implements ActionListener{		
		GridBagConstraints c;
		Container tab1;
		Container tab2;
		Container tab3;
		JTabbedPane tabbedPane = new JTabbedPane();
		public boolean OPEN = true;
		private JButton startB1 = new JButton("Start");
		private JButton startB2 = new JButton("Start");
		private JButton startB3 = new JButton("Start");
		ArrayList<JCheckBox> mTypes = new ArrayList<JCheckBox>();

		public GUI(){
			super("BatRuneSpan " + version);
			tabbedPane = new JTabbedPane();
			tab1 = new Container();
			tab1.setLayout(new GridBagLayout());
			tab2 = new Container();
			tab2.setLayout(new GridBagLayout());
			tab3 = new Container();
			tab3.setLayout(new GridBagLayout());
			c = new GridBagConstraints();
			c.fill = GridBagConstraints.HORIZONTAL;
			c.ipady = c.ipadx = 3;
			c.insets = new Insets(5, 5, 5, 5);
			makeMList();
			init();
			build();
			this.setLocationRelativeTo(getParent());
		}
		private void makeMList(){
			mTypes.add(new JCheckBox("Soul esswraith"));
			mTypes.add(new JCheckBox("Blood esswraith"));
			mTypes.add(new JCheckBox("Death esswraith"));
			mTypes.add(new JCheckBox("Law esshound"));
			mTypes.add(new JCheckBox("Nature esshound"));
			mTypes.add(new JCheckBox("Astral esshound"));
			mTypes.add(new JCheckBox("Chaos esshound"));
			mTypes.add(new JCheckBox("Cosmic esshound"));
			mTypes.add(new JCheckBox("Body esshound"));
			mTypes.add(new JCheckBox("Fire essling"));
			mTypes.add(new JCheckBox("Earth essling"));
			mTypes.add(new JCheckBox("Water essling"));
			mTypes.add(new JCheckBox("Mind essling"));
			mTypes.add(new JCheckBox("Air essling"));
		}

		private void build(){

			int row = 1;
			int col = 0;
			for(JCheckBox cb: mTypes){
				addToGrid(cb,row,col++,1,.25, tab1);
				if(col == 7){
					col = 0;
					row++;
				}
			}
			addToGrid(startB1,row++,col++,2,.25, tab1);


			addToGrid(startB2,0,0,1,.25, tab2);




			addToGrid(startB3,0,0,1,.25, tab3);


			tabbedPane.addTab("Monsters", tab1);
			tabbedPane.addTab("Nodes", tab2);
			tabbedPane.addTab("Options", tab3);
			getContentPane().add(tabbedPane);
			pack();
			setVisible(true);
		}
		private void init(){
			startB1.addActionListener(this);
			startB2.addActionListener(this);
			startB3.addActionListener(this);
		}
		private void addToGrid(Component comp, int gridx, int gridy, int gridwidth,
				double weightx, Container pane) {
			c.gridx = gridx;
			c.gridy = gridy;
			c.gridwidth = gridwidth;
			c.weightx = weightx;
			pane.add(comp, c);
		}

		public void actionPerformed(ActionEvent e) {
			for(JCheckBox cb: mTypes){
				if(cb.isSelected())monsterNames.add(cb.getText().toLowerCase());
				allMonsters.add(cb.getText().toLowerCase());
			}
			OPEN = false;
			dispose();
		}
	}
}