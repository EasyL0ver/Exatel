--[[
  ????????
  turtle????wrap??
  ????????????
  turtle: wrap??turtle API (CC)
  fallbackY: ???????????
]]

local MoveMgr = {}

MoveMgr.new = function(turtle, stat)
  local self = {
    x = 0,
    y = 0,
    z = 0,
    direction = 0, -- 0: North, 1: East, 2: South, 3: West

    station = {
      x = 0,
      y = 0,
      z = 0
    },

    fallbackY = 0,
    saveWhenMoved = false, -- if true, save stat when moved/turned
    turtle = turtle
  }

  if fs.exists(stat) then
    self = loadStat(stat)
  end
  setmetatable(self, {__index=MoveMgr})
  return self
end

-- start wrapper
function MoveMgr:up()
  local ret = {self.turtle.up()}
  assert(ret[1], "move up failed " .. (ret[2] or ""))
  self.y = self.y+1
  return true
end

function MoveMgr:down()
  local ret = {self.turtle.down()}
  assert(ret[1], "move down failed " .. (ret[2] or ""))
  self.y = self.y-1
  return true
end

function MoveMgr:turnLeft()
  self.turtle.turnLeft()
  self.direction = (self.direction + 3) % 4
  return true
end

function MoveMgr:turnRight()
  self.turtle.turnRight()
  self.direction = (self.direction + 1 )% 4
  return true
end

function MoveMgr:forward()
  local ret = {self.turtle.forward()}
  assert(ret[1], "move forward failed " .. (ret[2] or ""))
  local dir, diff = forwardAdd(self)
  self[dir] = self[dir] + diff
  return true
end

function MoveMgr:back()
  local ret = {self.turtle.back()}
  assert(ret[1], "move back failed " .. (ret[2] or ""))
  local dir, diff = forwardAdd(self)
  self[dir] = self[dir] - diff
  return true
end
-- wrapper end

function MoveMgr:turn(dir)
  assert( (0 <= dir) and (dir < 4), "must be 0<=dir < 4")
  local diff = ((dir - self.direction) + 4 )% 4
  if diff == 1 then
    self:turnRight()
  elseif diff == 2 then
    self:turnRight()
    self:turnRight()
  elseif diff == 3 then
    self:turnLeft()
  end
end

function MoveMgr:fuelToStation ()
  local need_x = math.abs(self.x - self.station.x)
  local need_y = math.abs(self.y - self.fallbackY) + math.abs(self.station.y - self.fallbackY)
  local need_z = math.abs(self.z - self.station.z)
  return need_x + need_y + need_z
end

function MoveMgr:isInStation()
  return ((self.x == self.station.x)
    and (self.y == self.station.y)
    and (self.z == self.station.z))
end

function MoveMgr:saveStat(filename)
  local f = io.open(filename, "w")
  f:write(textutils.serialize(self))
end

function MoveMgr:returnStation()
  -- move to fallback Y
  local diff = self.y - self.fallbackY
  while diff ~= 0 do
    local f = diff < 0 and self:up() or self:down()
    diff = self.y - self.fallbackY
  end

  diff = self.x - self.station.x
  while diff ~= 0 do
    local dir = diff < 0 and 1 or 3
    self:turn(dir)
    self:forward()

    diff = self.x - self.station.x
  end

  diff = self.z - self.station.z
  while diff ~= 0 do
    local dir = diff < 0 and 0 or 2
    self:turn(dir)
    self:forward()

    diff = self.z - self.station.z
  end

  local diff = self.y - self.station.y
  while diff ~= 0 do
    local f = diff < 0 and self:up() or self:down()
    diff = self.y - self.station.y
  end
end

function MoveMgr:strLoc()
  return "x: " .. self.x .. ", y: " .. self.y .. ", z: " .. self.z
end

-- private
function loadStat(filename)
  assert(fs.exists(filename), filename .. "is not found")
  local f, reason = io.open(filename, nil)
  assert(f ~= nil, reason)
  return textutils.unserialize(f:read("*a"))
end

function forwardAdd(movemgr)
  --[[
    pass movemgr
    return (x/z, -1,1) to add position record
  ]]
  local dir = movemgr.direction % 2 == 0 and "z" or "x"
  local distance = movemgr.direction < 2 and 1 or -1
  return dir, distance
end

return MoveMgr

--[[
 todo:
   test:
     turnLeft/right check round
]]