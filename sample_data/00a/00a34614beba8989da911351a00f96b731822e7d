#include "Table.h"
using namespace std;

Table::Table()
{

}

Table::~Table()
{

}

void Table::showState()
{
	int i = 0;
	for (auto & e : connections)
	{
		cout << i << ":" << e << " ,";
	}
}

Dice Table::getConnection(int index)
{
	int i = 0;
	for (auto & e : connections)
	{
		if (i++ == index)
		{
			return e;
		}
	}
}

bool Table::canConnect(int index, Dice dice)
{
	int i = 0;
	for (auto & e : connections)
	{
		if (i++ == index)
		{
			if (e.get_firstHalf == dice.get_firstHalf || e.get_secondHalf == dice.get_secondHalf)
				return true;
		}
	}
	return false;
}

void Table::connect(int index, Dice & dice)
{
	if(index == -1)
	{
		//Инициализация первого домино на столе
		connections.push_back(dice);
	}
	else
	{
		int i = 0;
		//int j = 0;
		for (auto & e : connections) 
		{
			if (i++ == index) 
			{
				if (e.isDouble)
				{
					if (e.get_leftDoubleConnection == NULL)
					{
						e.set_leftDoubleConnection(&dice);
						dice.set_rightDoubleConnection(&e);
					}
					else if (e.get_rightDoubleConnection == NULL)
					{
						e.set_rightDoubleConnection(&dice);
						dice.set_leftDoubleConnection(&e);
						e = dice;
					}
				}
				else
				{
					if (e.get_firstConnection == NULL)
					{
						e.set_firstConnection(&dice);
					}
					else if (e.get_secondConnection == NULL)
					{
						e.set_secondConnection(&dice);
						e = dice;
					}
				}

				////Удаляем место, которое занимаем, из множества свободных
				//for (auto iter = connections.begin(); iter != connections.end(); iter++)
				//{
				//	if (j++ == index) {
				//			connections.erase(iter);
				//			break;
				//	}
				//}
			}
		}
	}
}