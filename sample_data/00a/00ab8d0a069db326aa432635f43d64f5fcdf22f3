#include <conio.h>
#include <iostream>
#include <cmath>
#include <algorithm>

struct book
{
	char author[15];
	char title[15];
	int year;
	int requests;
};

struct Node
{
	Node* next;
	Node* prev;
	book cur;
};

struct deque
{
	int len;
	Node* startNode;
	Node* finishNode;
};

int length(deque D)
{
	return D.len;
}

deque initDeque()
{
	deque D;
	D.startNode = new Node;
	D.len = 0;
	D.finishNode = D.startNode;
	return D;
}

void push_back(deque &D, book element)
{
	++D.len;
	Node* curNode = new Node;
	curNode->cur = element;
	D.finishNode->next = curNode;
	curNode->prev = D.finishNode;
	D.finishNode = curNode;
}

book pop_front(deque &D)
{
	--D.len;
	Node* del = D.startNode;
	D.startNode = D.startNode->next;
	D.startNode->prev = NULL;
	delete del;
	return D.startNode->cur;
}

bool emptyDeque(deque &D)
{
	return !D.startNode;
}

void swapTails(deque &D)
{
	for (auto it = D.startNode; it != D.finishNode; it = it->prev)
	{
		std::swap(it->next, it->prev);
	}
	std::swap(D.finishNode->next, D.finishNode->prev);
	std::swap(D.startNode, D.finishNode);
}

void search(deque &D)
{
	for (auto it = D.startNode;; it = it->next)
	{
		if ((it->cur.year < 1980) && (it->cur.requests == 0))
		{
			printf("%s", it->cur.author);
			printf("%s", it->cur.title);
			printf("%d", it->cur.year);
			printf("%d", it->cur.requests);
			printf("\n");
		}
		if (it == D.finishNode)
			break;
	}
}

void addBook(deque &D)
{
	book A;
	printf("Введите фамилию и инициалы автора:\n");
	getchar();
	gets_s(A.author);
	printf("Введите название книги:\n");
	gets_s(A.title);
	printf("Введите год издания книги:\n");
	scanf_s("%d", &A.year);
	printf("Введите количество запросов книги:\n");
	scanf_s("%d", &A.requests);
	push_back(D, A);
}

void printDeque(deque &D)
{
	for (auto it = D.startNode;; it = it->next)
	{
		puts(it->cur.author);
		puts(it->cur.title);
		printf("%d\n", it->cur.year);
		printf("%d\n", it->cur.requests);
		printf("\n");
		if (it == D.finishNode)
			break;
	}
}

void addFromFile(deque &D)
{
	FILE* stream = fopen("Input.txt", "r");
	book A;
	while(fscanf(stream, "%s%s%d%d", A.author, A.title, &A.year, &A.requests) != EOF)
		push_back(D, A);
	fclose(stream);
}

void correctDeque(deque &D)
{
	for (auto it = D.startNode;; it = it->next)
	{
		if ((it->cur.year < 1800))
			it->cur.year = 1800;
		else if ((it->cur.year > 2018))
			it->cur.year = 2018;
		if (it == D.finishNode)
			break;
	}
}

void clearDeque(deque &D)
{
	while (!emptyDeque)
		pop_front(D);
}

void delElems(deque &D)
{
	int N;
	scanf_s("%d", &N);
	for (int i = 0; i < N, i < D.len; i++)
		pop_front(D);
}

void writeInFile(deque &D)
{
	FILE* stream = fopen("Output.txt", "w");
	for (auto it = D.startNode;; it = it->next)
	{
		fprintf(stream, "%s%s%d%d", it->cur.author, it->cur.title, it->cur.year, it->cur.requests);
		if (it == D.finishNode)
			break;
	}
	fclose(stream);
}

int main()
{
	setlocale(LC_ALL, "Russian");
	deque D = initDeque();
	int key = -1;
	while (key != 0)
	{
		printf("МЕНЮ\n1.Добавить книгу с клавиатуры\n2.Вывести дек на экран\n3.Поиск\n4.Корректировка\n5.Очистить дек\n6.Загрузить данные из файла\n7.Удалить N элементов\n8.Запись содержимого в файл\n9.Разделить дек на два\n0.Выход\n");
		scanf_s("%d", &key);
	    switch (key)
		{
		case 1:
			addBook(D);
			break;
		case 2:
			printDeque(D);
			break;
		case 3:
			search(D);
			break;
		case 4:
			correctDeque(D);
			break;
		case 5:
			clearDeque(D);
			break;
		case 6:
			addFromFile(D);
			break;
		case 7:
			delElems(D);
			break;
		case 8:
			writeInFile(D);
			break;
		default:
			printf("Некорректный выбор. Нажмите любую клавишу.");
		}
		printf("\n");
	}
	_getch();
	return 0;
}