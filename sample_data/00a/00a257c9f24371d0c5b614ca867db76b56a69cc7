---------------------------Tworzenie instancji, początkowa konfiguracja----------------------------------------
	db2ilist - lista instancji
	db2icrt nazwaInstancji - tworzenie nowej instancji
	set db2instance=nazwaInstancji - ustawienie instancji
	db2sample -sql -xml - tworzenie przykładowej bazy danych
	db2 list db directory - lista baz danych
	db2set -all - zwraca ustawiony rejestr profili db2
	db2set db2comm=tcpip - ustawienie do komunikacji



	db2icrt instName
	set db2instance=instName
	db2 get instance
	db2sample -sql -xml
	db2 list db directory
	db2set db2comm=tcpip
	db2set -all
	db2start

	db2 update dbm cfg using SVCENAME nazwaWServices
	db2 get dbm cfg
	db2stop
	db2start

---------------------------Podstawowe zapytania do bazy danych-------------------------------------------------
	--1. Podać nazwisko i imiona pracowników zaczynające się na literę od c do s.
	SELECT FIRSTNME, LASTNAME
	FROM employee
	WHERE SUBSTR(LCASE(LASTNAME), 1, 1) BETWEEN 'c' and 's';

	--2. Podać nazwisko i imiona pracowników zaczynające się na literę od c do s trzecia nie l.
	SELECT firstnme, lastname FROM EMPLOYEE WHERE SUBSTR(LCASE(LASTNAME), 1, 1) BETWEEN 'c' AND 's'
	AND SUBSTR(LCASE(LASTNAME), 3, 1) NOT IN ('l');

	--3. Podać pracowników, których pensja jest > od 30 000 zł.
	SELECT FIRSTNME, LASTNAME, SALARY
	FROM EMPLOYEE
	WHERE SALARY > 30000;

	--4. Podać pracowników, których pensja z dodaniem prowizji jest > od 50 000 zł i są kobietami.
	SELECT LASTNAME, FIRSTNME, SEX, SALARY, BONUS
	FROM EMPLOYEE
	WHERE SEX = 'F' AND (SALARY + BONUS) > 50000;
	
	--5. Wyświetlić pensję pracownika netto, policzyć 18% podatek i podać pensję z podatkiem.
	SELECT SALARY, (SALARY * 0.18) AS "Podatek", (SALARY * 0.18 + SALARY) AS "Pensja z podatkiem"
	FROM EMPLOYEE;

	--6. Podać czas z zegara systemowego i datę zegara systemowego.	
	SELECT CURRENT DATE AS "Data", CURRENT TIME AS "Godzina"
	FROM SYSIBM.SYSDUMMY1;

	--7. Podać, którzy z pracowników są w wieku z przedziału 30 do 50 lat.	
	a)
	SELECT EMPLOYEE.BIRTHDATE, EMPLOYEE.FIRSTNME, (YEAR(CURRENT DATE) - YEAR(EMPLOYEE.BIRTHDATE)) AS WIEK
	FROM EMPLOYEE, SYSIBM.SYSDUMMY1
	WHERE (YEAR(CURRENT DATE) - YEAR(EMPLOYEE.BIRTHDATE)) > 30
    AND (YEAR(CURRENT DATE) - YEAR(EMPLOYEE.BIRTHDATE)) < 50;

	b)
	SELECT EMPLOYEE.BIRTHDATE, EMPLOYEE.FIRSTNME, (YEAR(CURRENT DATE) - YEAR(EMPLOYEE.BIRTHDATE)) AS WIEK
	FROM EMPLOYEE, SYSIBM.SYSDUMMY1
	WHERE (YEAR(CURRENT DATE) - YEAR(EMPLOYEE.BIRTHDATE)) between 30 and 50;

	--8. Podać w jakim dziale pracuje pracownik.
	SELECT LASTNAME, FIRSTNME, WORKDEPT
	FROM EMPLOYEE;

	--9. Podaj w jakim dziale pracuje pracownik i uporządkuj malejąco po dziale i rosnąco po nazwisku.	
	SELECT LASTNAME, FIRSTNME, WORKDEPT
	FROM EMPLOYEE
	ORDER BY WORKDEPT DESC, LASTNAME ASC;

	--10. Podaj w jakim dziale pracuje pracownik i uporządkuj malejąco po dziale i rosnąco po nazwisku ograniczając liczbę krotek do działów zaczynających się na literę a lub s.	
	SELECT LASTNAME, FIRSTNME, WORKDEPT
	FROM EMPLOYEE
	WHERE WORKDEPT LIKE 'A%' OR WORKDEPT LIKE 'S%'
	ORDER BY WORKDEPT DESC, LASTNAME ASC;	
	
	--11. Czy jest dział firmy w którym nikt nie pracuje.	
	SELECT d.DEPTNAME, e.LASTNAME 
	FROM DEPARTMENT d left join EMPLOYEE e on d.DEPTNO = e.WORKDEPT 
	WHERE e.LASTNAME is null;

	-- znaleźć pracownika zarabiającego najwięcej na każdym stanowisku pracy w każdym departamencie
	-- znaleźć pracownika zarabiającego najwięcej na każdym stanowisku pracy 
	SELECT FIRSTNME, JOB, SALARY FROM EMPLOYEE order by 2, 3 desc;

	SELECT LASTNAME, JOB, SALARY 
	FROM EMPLOYEE e1 
	WHERE salary IN (select max(salary) from employee e2 where e2.job=e1.job );

	--Czas systemowy:
	SELECT CURRENT_TIME
	FROM SYSIBM.SYSDUMMY1;

	--Data systemowa
	SELECT CURRENT SCHEMA
	 FROM SYSIBM.DUAL;

	--Dual alias do sysdummy1
	SELECT CURRENT DATE
	FROM SYSIBM.DUAL;

	--3 pierwsze linie
	SELECT * FROM DEPARTMENT
	FETCH FIRST 3 ROWS ONLY;
  
	--dane testowe
	VALUES 6, 7, 8;
	VALUES (6, 'test'), (7, 'nowy'), (8, NULL);

	--cte--- zapytania commond table expresion
	WITH
	  TEMP1 (A1, A2) AS
		 (VALUES (6, 'test'), (7, 'nowy'), (8, NULL)),
	  TEMP2 (A1, A2) AS
		 (VALUES (1, 'test'), (2, 'nowy'), (3, NULL)),
	  TEMP3 AS
		 (SELECT MAX(A1) AS TEST
			FROM TEMP1)
	SELECT * FROM TEMP3;

	
	SELECT * FROM EMPLOYEE;
	SELECT * FROM DEPARTMENT;

	--Ile osób pracuje w każdym z działów
	SELECT D.DEPTNO, COUNT(E.LASTNAME)
	FROM DEPARTMENT AS D JOIN EMPLOYEE AS E ON D.DEPTNO = E.WORKDEPT
	GROUP BY D.DEPTNO;

	--Testy na widokach:
	CREATE TABLE TABLE1 (C1 INTEGER, C2 CHAR(5));

	SELECT * FROM TABLE1;

	INSERT INTO TABLE1 VALUES (100, 'ABC');
	INSERT INTO TABLE1 VALUES (200, 'DEF');

	CREATE OR REPLACE VIEW VIEW1 AS SELECT C1,C2 FROM TABLE1;

	SELECT * FROM VIEW1;

	INSERT INTO VIEW1 VALUES (100, 'DEF');
-----------------Własne typy danych, tworzenie tabel Ocena oraz Studenci, Trigger do wstawiania przez widok------------------------------------
	--Własny typ danych:
	CREATE DISTINCT TYPE OCENA AS DECIMAL(5,1) WITH COMPARISONS;
	
	--Tworzenie tabeli STUDENCI
	CREATE TABLE STUDENCI(
	IDSTUDENTA INTEGER NOT NULL GENERATED ALWAYS AS IDENTITY
	(START WITH 1 INCREMENT BY 1),
	NAZWISKO VARCHAR(50),
	IMIE VARCHAR(25),
	PRIMARY KEY (IDSTUDENTA))
	
	--Tworzenie tabeli OCENY
	CREATE TABLE OCENY(
	IDSTUDENTA INTEGER NOT NULL, 
	OCENA OCENA NOT NULL)
	
	--Tworzenie klucz obcego w tabeli OCENY
	ALTER TABLE OCENY ADD CONSTRAINT FK_OCENY_STUD 
	FOREIGN KEY(IDSTUDENTA) REFERENCES  STUDENCI(IDSTUDENTA)

	--Tworznie ograniczenia przy wstawianiu do tabeli OCENY
	ALTER TABLE OCENY ADD CONSTRAINT SPR_OCENE
	CHECK (CAST(OCENA AS DECIMAL(5,1)) IN (2, 2.5, 3, 3.5, 4, 4.5, 5))

	--Wstawienie przykładowych rekordów do tabeli STUDENCI
	INSERT INTO STUDENCI(NAZWISKO, IMIE) VALUES ('KOWALSKI', 'JAN');
	INSERT INTO STUDENCI (NAZWISKO, IMIE) VALUES ('NOWAK', 'JAN');
	INSERT INTO STUDENCI (NAZWISKO, IMIE) VALUES ('NOWACKI', 'JAN');

	SELECT * FROM STUDENCI;
	SELECT * FROM OCENY;

	--Wstawienie przykładowych rekordów do tabeli OCENY
	INSERT INTO OCENY VALUES (2, 5);
	INSERT INTO OCENY VALUES (2, 4);

	--Pobranie danych z tabel STUDENCI oraz OCENY przy użyciu inner joina
	SELECT S.IDSTUDENTA, S.NAZWISKO, S.IMIE, O.OCENA
	FROM STUDENCI AS S INNER JOIN OCENY AS O ON S.IDSTUDENTA = O.IDSTUDENTA;

	--Wyliczenie średniej ocen studenta
	SELECT S.NAZWISKO, S.IMIE, CAST (AVG(CAST (O.OCENA AS DECIMAL (5,1))) AS DECIMAL (5,1)) AS SREDNIA
	FROM STUDENCI AS S INNER JOIN OCENY AS O ON S.IDSTUDENTA = O.IDSTUDENTA
	GROUP BY S.IMIE, S.NAZWISKO;

	--Stworzenie widoku na podstawie poprzedniego SELECTA
	CREATE OR REPLACE VIEW WIDOKSTUDENCKI
	AS SELECT S.NAZWISKO, S.IMIE,
	CAST(AVG(CAST(OCENA AS DECIMAL(5,1))) AS DECIMAL(5,1)) SREDNIA
	FROM STUDENCI S INNER JOIN OCENY O ON S.IDSTUDENTA=O.IDSTUDENTA
	GROUP BY S.IMIE, S.NAZWISKO;

	SELECT * FROM WIDOKSTUDENCKI
	
--INSTEAD OF INSERT (NEW)
--Trigger do wstawiania do tabeli przez widok
	CREATE OR REPLACE TRIGGER WSTDOWIDOKSTUDENCKI
	INSTEAD OF INSERT ON WIDOKSTUDENCKI REFERENCING NEW AS N 
	FOR EACH ROW MODE DB2SQL
	BEGIN ATOMIC
		DECLARE VARIDSTUDENTA INTEGER;
		SET (VARIDSTUDENTA) = (SELECT IDSTUDENTA FROM STUDENCI WHERE IMIE = N.IMIE AND NAZWISKO = N.NAZWISKO);
		IF VARIDSTUDENTA IS NOT NULL THEN 
			INSERT INTO OCENY(IDSTUDENTA, OCENA) VALUES(VARIDSTUDENTA, N.SREDNIA);
		END IF;
	END

	INSERT INTO WIDOKSTUDENCKI VALUES('KOWALSKI', 'JAN',2)
	SELECT * FROM OCENY
	SELECT * FROM STUDENCI
	SELECT * FROM WIDOKSTUDENCKI

-----------------------------Pracownicz - tworzenie tabel, nakładanie ograniczeń, trigger tworzący prowizoryczny log------------------------------------------
--Stworzenie tabeli PRAOWNICY w schemacie KOLOKWIUM
	CREATE TABLE KOLOKWIUM.PRACOWNICY(
		IDPRACOWNIKA INTEGER NOT NULL GENERATED ALWAYS AS IDENTITY
		(START WITH 1 INCREMENT BY 1),
		NAZWISKO VARCHAR(50) NOT NULL,
		IMIE VARCHAR(25) NOT NULL,
		PENSJA INTEGER NOT NULL,
		PRIMARY KEY(IDPRACOWNIKA)
	)

	SELECT * FROM KOLOKWIUM.PRACOWNICY

	--Stworzenie tabeli PRACKOP w schemacie KOLOKWIUM
	CREATE TABLE KOLOKWIUM.PRACKOP(
		IDPRACOWNIKA INTEGER NOT NULL,
		NAZWISKO VARCHAR(50) NOT NULL,
		IMIE VARCHAR(25) NOT NULL,
		PENSJA INTEGER NOT NULL,
		"DATA" TIMESTAMP NOT NULL,
		LOGIN VARCHAR(50)
	)

	--Nadanie klucza głównego w tabeli PRACOWNICY
	ALTER TABLE KOLOKWIUM.PRACOWNICY ADD CONSTRAINT FK_OCENY_STUD 
	PRIMARY KEY(IDPRACOWNIKA)

	--Nadanie ograniczneia na wstawienie do tabeli PRACOWNICY
	ALTER TABLE KOLOKWIUM.PRACOWNICY ADD CONSTRAINT SPR_PENSJE
	CHECK (PENSJA BETWEEN 500 AND 1500)

	SELECT * FROM KOLOKWIUM.PRACOWNICY

	INSERT INTO KOLOKWIUM.PRACOWNICY(NAZWISKO, IMIE, PENSJA) VALUES('Kowalski', 'Jan', 700)

	--AFTER DELETE (OLD)
	--Trigger, który tworzy coś w rodzaju logów.
	CREATE OR REPLACE TRIGGER LOGI
	AFTER DELETE ON KOLOKWIUM.PRACOWNICY
	REFERENCING OLD AS OOO
	FOR EACH ROW
	MODE DB2SQL
	BEGIN ATOMIC
		DECLARE KIEDY TIMESTAMP;
		DECLARE CURRENTUSER VARCHAR(50);

		SET KIEDY = (SELECT CURRENT TIMESTAMP FROM SYSIBM.SYSDUMMY1);
		SET CURRENTUSER = (SELECT CURRENT USER FROM SYSIBM.SYSDUMMY1);

		INSERT INTO KOLOKWIUM.PRACKOP VALUES (IDPRACOWNIKA, NAZWISKO, IMIE, PENSJA, KIEDY, CURRENTUSER);
	END!

	--Testy działani triggera:
	SELECT * FROM KOLOKWIUM.PRACOWNICY
	SELECT * FROM KOLOKWIUM.PRACKOP

	DELETE FROM KOLOKWIUM.PRACOWNICY WHERE IDPRACOWNIKA = 6
	INSERT INTO KOLOKWIUM.PRACOWNICY(NAZWISKO, IMIE, PENSJA) VALUES(NULL, NULL, 800)
	INSERT INTO KOLOKWIUM.PRACOWNICY(NAZWISKO, IMIE, PENSJA) VALUES('Gallus', 'Agata', 1250)

	--BEFORE INSERT (NEW)
	--Trigger testowy przy wstawianiu wartości NULL jako imie i/lub nazwisko:
	CREATE OR REPLACE TRIGGER TEST_TRIGGERA
	NO CASCADE BEFORE INSERT ON
	KOLOKWIUM.PRACOWNICY
	REFERENCING NEW AS N
	FOR EACH ROW
	MODE DB2SQL
	BEGIN ATOMIC
		IF(N.NAZWISKO IS NULL) THEN