#include "../includes.h"

#include "../UTILS/interfaces.h"
#include "../UTILS/render.h"
#include "../SDK/CClientEntityList.h"
#include "../SDK/IEngine.h"
#include "../SDK/CBaseAnimState.h"
#include "../SDK/CGlobalVars.h"
#include "../SDK/GameEvents.h"
#include "../SDK/CTrace.h"
#include "../SDK/Collideable.h"

#include "../FEATURES/Backtracking.h"
#include "../FEATURES/InGameLogger.h"
#include "../FEATURES/Autowall.h"

#include "Resolver1.h"
#include "RageBot.h"
#include "RenderManager.h"
#include "Autowall.h"
#include <iostream>
#include "chrono"
#include "UTIL Functions.h"
#include "interfaces.h"
#include "quickmaths.h"
#include "movedata.h"
#include "extrahelper.h"
#include "CBaseAnimState.h"
#include "EngineClient.h"
#include "memalloc.h"
#include "checksum_md5.h"
#include "EnginePrediction.h"
#include "EdgyLagComp.h"
#include "FakeLag.h"
#include "Resolver.h"
#include "Backtracking.h"
#include "LagCompensation.h"
#include "backtracking.h"
#include "math.h"
#include "Backtracking.h"

#define enc_str(s) std::string(s)
#define enc_char(s) enc_str(s).c_str()
#define enc_wstr(s) std::wstring(enc_str(s).begin(), enc_str(s).end())
#define enc_wchar(s) enc_wstr(s).c_str()

#define NOCOLOR Color(0, 0, 0, 0)
#define WHITE Color(255, 255, 255, 255)
#define BLACK Color(0, 0, 0, 255)
#define RED Color(255, 0, 0, 255)
#define LIGHTRED Color(255, 100, 100, 255)
#define DARKRED Color(120, 0, 0, 255)
#define GREEN Color(0, 255, 0, 255)
#define BLUE Color(0, 0, 255, 255)
#define DARKGREY Color(55, 55, 55, 255)
#define GREY Color(70, 70, 70, 255)
#define LIGHTGREY Color(150, 150, 150, 255)
#define HOTPINK Color(255,20,147, 255)
#define CYAN Color(0,255,255, 255)
#define YELLOW Color(255, 255, 0)
#define ORANGE Color(255,100,75)

namespace FEATURES
{
	namespace RAGEBOT
	{
		Resolver resolver1;

		Resolver::Resolver() { }

		void Resolver::DoFSN()
		{
			auto local_player = Interfaces::EntList->GetClientEntity->GetClientEntity(Interfaces::Engine->GetLocalPlayer());
			if (!local_player || local_player->GetHealth() <= 0)
				return;

			for (int i = 0; i < Interfaces::Globals->maxClients; i++)
			{
				auto entity = Interfaces::EntList->GetClientEntity->GetClientEntity(i);
				if (!entity || entity->GetHealth() <= 0 || entity->GetTeam() == local_player->GetTeam() || !entity->IsAlive())
					continue;

				UpdateResolveRecord(entity);

				/// make sure to do dormant check AFTER calling UpdateResolveRecord()
				if (entity->GetIsDormant())
					continue;

				ResolveYaw(entity);
				ResolvePitch(entity);

				const auto resolve_record = player_resolve_records[i];
				entity->SetEyeAngles(resolve_record.resolved_angles);
			}
		}

		float GetCurtime2()
		{
			if (!Interfaces::Engine->IsConnected() || !Interfaces::Engine->IsInGame())
				return 0.f;

			IClientEntity* pLocal = Interfaces::EntList->GetClientEntity(Interfaces::Engine->GetLocalPlayer());

			if (!pLocal)
				return 0.f;

			return pLocal->GetTickBase() * Interfaces::Globals->interval_per_tick;
		}

		void Resolver::DoCM()
		{
			auto local_player = Interfaces::EntList->GetClientEntity->GetClientEntity(Interfaces::Engine->GetLocalPlayer());
			if (!local_player || local_player->GetHealth() <= 0)
				return;

			ProcessSnapShots();

			last_eye_positions.insert(last_eye_positions.begin(), local_player->GetVecOrigin() + local_player->GetViewOffset());
			if (last_eye_positions.size() > 128)
				last_eye_positions.pop_back();

			auto nci = Interfaces::Engine->GetNetChannelInfo();
			if (!nci)
				return;

			const int latency_ticks = TIME_TO_TICKS(nci->GetLatency(FLOW_OUTGOING));
			const auto latency_based_eye_pos = last_eye_positions.size() <= latency_ticks ? last_eye_positions.back() : last_eye_positions[latency_ticks];
			//RENDER::render_queue.AddDrawCircle(latency_based_eye_pos, 2, 50, RED);
			for (int i = 0; i < Interfaces::Globals->maxClients; i++)
			{
				auto entity = Interfaces::EntList->GetClientEntity->GetClientEntity(i);
				if (!entity || entity->GetHealth() <= 0 || entity->GetTeam() == local_player->GetTeam() || entity->GetIsDormant() || !entity->IsAlive())
					continue;

				auto& resolve_record = player_resolve_records[i];

				const float height = 64;

				Vector direction_1, direction_2;
				MATH::AngleVectors(Vector(0.f, MATH::CalcAngle(local_player->GetVecOrigin(), entity->GetVecOrigin()).y - 90.f, 0.f), &direction_1);
				MATH::AngleVectors(Vector(0.f, MATH::CalcAngle(local_player->GetVecOrigin(), entity->GetVecOrigin()).y + 90.f, 0.f), &direction_2);

				const auto left_eye_pos = entity->GetVecOrigin() + Vector(0, 0, height) + (direction_1 * 16.f);
				const auto right_eye_pos = entity->GetVecOrigin() + Vector(0, 0, height) + (direction_2 * 16.f);

				resolve_record.anti_freestanding_record.left_damage = FEATURES::RAGEBOT::autowall.CalculateDamage(latency_based_eye_pos,
					left_eye_pos, local_player, entity, 1).damage;
				resolve_record.anti_freestanding_record.right_damage = FEATURES::RAGEBOT::autowall.CalculateDamage(latency_based_eye_pos,
					right_eye_pos, local_player, entity, 1).damage;

				trace_t tr;
				Ray_t ray;
				CTraceFilter filter;

				ray.Init(left_eye_pos, latency_based_eye_pos);
				Interfaces::Trace->TraceRay(ray, MASK_ALL, &filter, &tr);
				resolve_record.anti_freestanding_record.left_fraction = trace.flFraction;

				ray.Init(right_eye_pos, latency_based_eye_pos);
				Interfaces::Trace->TraceRay(ray, MASK_ALL, &filter, &tr);
				resolve_record.anti_freestanding_record.right_fraction = trace.flFraction;

				resolve_record.did_predicted_lby_flick = false;
				resolve_record.did_lby_flick = false;
			}
		}

		void Resolver::AddShotSnapshot(IClientEntity* entity, PlayerResolveRecord resolve_record)
		{
			ShotSnapshot snapshot;

			snapshot.entity = entity;
			snapshot.time = Interfaces::Globals->curtime;
			snapshot.resolve_record = resolve_record;
			snapshot.first_processed_time = 0.f;
			snapshot.was_shot_processed = false;
			snapshot.hitgroup_hit = -1;

			shot_snapshots.push_back(snapshot);
		}

		void Resolver::EventCallback(SDK::IGameEvent* game_event, IGameEvent *Event)
		{
			auto local_player = Interfaces::EntList->GetClientEntity->GetClientEntity(Interfaces::Engine->GetLocalPlayer());
			if (!local_player || local_player->GetHealth() <= 0 || !game_event)
				return;

			if (shot_snapshots.size() <= 0)
				return;

			auto& snapshot = shot_snapshots.front();
			switch (UTILS::FNVHashEx(Event->GetName()))
			{
			case UTILS::FNVHashEx("player_hurt"):
			{
				int attacker = Event->GetInt("attacker");
				int deadfag = Event->GetInt("userid");
				/// it wasn't us who shot
				if (Interfaces::Engine->GetPlayerForUserID(attacker)) != Interfaces::Engine->GetLocalPlayer())
					return;

				if (!snapshot.was_shot_processed)
				{
					snapshot.was_shot_processed = true;
					snapshot.first_processed_time = GetCurtime2();
				}

				snapshot.hitgroup_hit = Event->GetInt(enc_char("hitgroup"));

				break;
			}
			case UTILS::FNVHashEx("bullet_impact"): //if (!strcmp(event->GetName(), "bullet_impact"))
			case UTILS::FNVHashEx("weapon_fire"):
			{
				/// it wasn't us who shot
				if (Interfaces::Engine->GetPlayerForUserID(Event->GetInt(enc_char("userid"))) != Interfaces::Engine->GetLocalPlayer())
					return;

				if (!snapshot.was_shot_processed)
				{
					snapshot.was_shot_processed = true;
					snapshot.first_processed_time = GetCurtime2();
				}

				break;
			}
			}
		}



		void Resolver::ProcessSnapShots()
		{
			if (shot_snapshots.size() <= 0)
				return;

			const auto snapshot = shot_snapshots.front();
			if (fabs(GetCurtime2() - snapshot.time) > 1.f)
			{
				//LOG(enc_char("** Unhandled shot snapshot!"));
				//FEATURES::MISC::in_game_logger.AddLog(FEATURES::MISC::InGameLogger::Log(enc_char("Unhandled shot snapshot!"), RED));

				shot_snapshots.erase(shot_snapshots.begin());
				return;
			}

			const int player_index = snapshot.entity->GetIndex();
			if (snapshot.hitgroup_hit != -1) /// hit
			{
				/// increment shots fired and shots hit
				for (int i = 0; i < RESOLVE_TYPE_NUM; i++)
				{
					if (snapshot.resolve_record.resolve_type & (1 << i))
					{
						player_resolve_records[player_index].shots_fired[i]++;
						player_resolve_records[player_index].shots_hit[i]++;
					}
				}

				FEATURES::MISC::in_game_logger.AddLog(FEATURES::MISC::InGameLogger::Log("[RESOLVER] Hit at " + TranslateResolveRecord(snapshot.resolve_record.resolve_type), GREEN));
			}
			else if (snapshot.first_processed_time != 0.f && fabs(GetCurtime2() - snapshot.first_processed_time) > 0.1f) /// missed
			{
				/// increment shots fired but not shots hit
				for (int i = 0; i < RESOLVE_TYPE_NUM; i++)
				{
					if (snapshot.resolve_record.resolve_type & (1 << i))
						player_resolve_records[player_index].shots_fired[i]++;
				}

				if (snapshot.resolve_record.resolve_type & RESOLVE_TYPE_LAST_MOVING_LBY)
					player_resolve_records[player_index].shots_missed_moving_lby++;

				if (snapshot.resolve_record.resolve_type & RESOLVE_TYPE_LAST_MOVING_LBY_DELTA)
					player_resolve_records[player_index].shots_missed_moving_lby_delta++;

				FEATURES::MISC::in_game_logger.AddLog(FEATURES::MISC::InGameLogger::Log("[RESOLVER] Missed at " + TranslateResolveRecord(snapshot.resolve_record.resolve_type), RED));
			}
			else
				return;

			shot_snapshots.erase(shot_snapshots.begin());
		}

		void Resolver::UpdateResolveRecord(IClientEntity* entity)
		{
			/// a copy of the previous record for comparisons and shit
			const auto previous_record = player_resolve_records[entity->GetIndex()];
			auto& record = player_resolve_records[entity->GetIndex()];

			record.resolved_angles = record.networked_angles;
			record.velocity = entity->GetVelocity();
