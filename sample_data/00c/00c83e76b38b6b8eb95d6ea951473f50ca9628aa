--//====================================================\\--
--||			   CREATED BY SHACKLUSTER
--\\====================================================//--
if game:GetService("RunService"):IsClient() then error("Script must be server-side in order to work; use h/ and not hl/") end
local Player,game,owner = owner,game
local RealPlayer = Player
do
	print("FE Compatibility code by Mokiros")
	local rp = RealPlayer
	script.Parent = rp.Character
	
	--RemoteEvent for communicating
	local Event = Instance.new("RemoteEvent")
	Event.Name = "UserInput_Event"

	--Fake event to make stuff like Mouse.KeyDown work
	local function fakeEvent()
		local t = {_fakeEvent=true,Functions={},Connect=function(self,f)table.insert(self.Functions,f) end}
		t.connect = t.Connect
		return t
	end

	--Creating fake input objects with fake variables
    local m = {Target=nil,Hit=CFrame.new(),KeyUp=fakeEvent(),KeyDown=fakeEvent(),Button1Up=fakeEvent(),Button1Down=fakeEvent()}
	local UIS = {InputBegan=fakeEvent(),InputEnded=fakeEvent()}
	local CAS = {Actions={},BindAction=function(self,name,fun,touch,...)
		CAS.Actions[name] = fun and {Name=name,Function=fun,Keys={...}} or nil
	end}
	--Merged 2 functions into one by checking amount of arguments
	CAS.UnbindAction = CAS.BindAction

	--This function will trigger the events that have been :Connect()'ed
	local function te(self,ev,...)
		local t = m[ev]
		if t and t._fakeEvent then
			for _,f in pairs(t.Functions) do
				f(...)
			end
		end
	end
	m.TrigEvent = te
	UIS.TrigEvent = te

	Event.OnServerEvent:Connect(function(plr,io)
	    if plr~=rp then return end
		m.Target = io.Target
		m.Hit = io.Hit
		if not io.isMouse then
			local b = io.UserInputState == Enum.UserInputState.Begin
			if io.UserInputType == Enum.UserInputType.MouseButton1 then
				return m:TrigEvent(b and "Button1Down" or "Button1Up")
			end
			for _,t in pairs(CAS.Actions) do
				for _,k in pairs(t.Keys) do
					if k==io.KeyCode then
						t.Function(t.Name,io.UserInputState,io)
					end
				end
			end
			m:TrigEvent(b and "KeyDown" or "KeyUp",io.KeyCode.Name:lower())
			UIS:TrigEvent(b and "InputBegan" or "InputEnded",io,false)
	    end
	end)
	Event.Parent = NLS([==[
	local Player = game:GetService("Players").LocalPlayer
	local Event = script:WaitForChild("UserInput_Event")

	local Mouse = Player:GetMouse()
	local UIS = game:GetService("UserInputService")
	local input = function(io,a)
		if a then return end
		--Since InputObject is a client-side instance, we create and pass table instead
		Event:FireServer({KeyCode=io.KeyCode,UserInputType=io.UserInputType,UserInputState=io.UserInputState,Hit=Mouse.Hit,Target=Mouse.Target})
	end
	UIS.InputBegan:Connect(input)
	UIS.InputEnded:Connect(input)

	local h,t
	--Give the server mouse data 30 times every second, but only if the values changed
	--If player is not moving their mouse, client won't fire events
	while wait(1/30) do
		if h~=Mouse.Hit or t~=Mouse.Target then
			h,t=Mouse.Hit,Mouse.Target
			Event:FireServer({isMouse=true,Target=t,Hit=h})
		end
	end]==],Player.Character)

	----Sandboxed game object that allows the usage of client-side methods and services
	--Real game object
	local _rg = game

	--Metatable for fake service
	local fsmt = {
		__index = function(self,k)
			local s = rawget(self,"_RealService")
			if s then return s[k] end
		end,
		__newindex = function(self,k,v)
			local s = rawget(self,"_RealService")
			if s then s[k]=v end
		end,
		__call = function(self,...)
			local s = rawget(self,"_RealService")
			if s then return s(...) end
		end
	}
	local function FakeService(t,RealService)
		t._RealService = typeof(RealService)=="string" and _rg:GetService(RealService) or RealService
		return setmetatable(t,fsmt)
	end

	--Fake game object
	local g = {
		GetService = function(self,s)
			return self[s]
		end,
		Players = FakeService({
			LocalPlayer = FakeService({GetMouse=function(self)return m end},Player)
		},"Players"),
		UserInputService = FakeService(UIS,"UserInputService"),
		ContextActionService = FakeService(CAS,"ContextActionService"),
	}
	rawset(g.Players,"localPlayer",g.Players.LocalPlayer)
	g.service = g.GetService
	
	g.RunService = FakeService({
		RenderStepped = _rg:GetService("RunService").Heartbeat,
		BindToRenderStep = function(self,name,_,fun)
			self._btrs[name] = self.Heartbeat:Connect(fun)
		end,
		UnbindFromRenderStep = function(self,name)
			self._btrs[name]:Disconnect()
		end,
	},"RunService")

	setmetatable(g,{
		__index=function(self,s)
			return _rg:GetService(s) or typeof(_rg[s])=="function"
			and function(_,...)return _rg[s](_rg,...)end or _rg[s]
		end,
		__newindex = fsmt.__newindex,
		__call = fsmt.__call
	})
	--Changing owner to fake player object to support owner:GetMouse()
	game,owner = g,g.Players.LocalPlayer
end

Player = owner
    Character = Player.Character
    local txt = Instance.new("BillboardGui", Character)
    txt.Adornee = Character.Head
    txt.Name = "_status"
    txt.Size = UDim2.new(2, 0, 1.2, 0)
    txt.StudsOffset = Vector3.new(-9, 8, 0)
    local text = Instance.new("TextLabel", txt)
    text.Size = UDim2.new(10, 0, 7, 0)
    text.FontSize = "Size24"
    text.TextScaled = true
    text.TextTransparency = 0
    text.BackgroundTransparency = 10
    text.TextTransparency = 0
    text.TextStrokeTransparency = 0
    text.Font = "Antique"
    text.TextStrokeColor3 = Color3.new(0,0,0)
        text.Text = "Terra God"


local createstuff = function()
	local stuff = Instance.new("Model")
local collar = Instance.new("Part")
local mesh = Instance.new("FileMesh")
local part = Instance.new("Part")
local mesh_2 = Instance.new("CylinderMesh")
local weld = Instance.new("ManualWeld")
local eye = Instance.new("Part")
local mesh_3 = Instance.new("SpecialMesh")
local decal = Instance.new("Decal")
local hood = Instance.new("Part")
local mesh_4 = Instance.new("FileMesh")
local pillar = Instance.new("Part")
local rock = Instance.new("Part")
local core = Instance.new("Attachment")
local emit = Instance.new("ParticleEmitter")
local mesh_5 = Instance.new("FileMesh")
local rockspike = Instance.new("Part")
local mesh_6 = Instance.new("SpecialMesh")
local shield = Instance.new("Part")
local core_2 = Instance.new("Attachment")
local spinepart = Instance.new("Part")
local mesh_7 = Instance.new("FileMesh")
local pants = Instance.new("Pants")
local shirt = Instance.new("Shirt")
local emit_2 = Instance.new("ParticleEmitter")
local vortex = Instance.new("ParticleEmitter")
local wave = Instance.new("ParticleEmitter")

stuff.Name = "Stuff"
stuff.Parent = workspace
collar.Size = Vector3.new(2.06, 0.2, 2.06)
collar.Name = "Collar"
collar.Material = Enum.Material.Metal
collar.TopSurface = Enum.SurfaceType.Smooth
collar.BottomSurface = Enum.SurfaceType.Smooth
collar.Parent = stuff
collar.CFrame = CFrame.new(5.8, 46.2, -39.9)
mesh.MeshId = "rbxassetid://1861264141"
mesh.Parent = collar
part.Size = Vector3.new(1.3, 0.2, 1.3)
part.BrickColor = BrickColor.new("Really black")
part.Color = Color3.new(0.109804, 0.0823529, 0.117647)
part.Material = Enum.Material.Metal
part.TopSurface = Enum.SurfaceType.Smooth
part.BottomSurface = Enum.SurfaceType.Smooth
part.Parent = collar
part.CFrame = CFrame.new(5.8, 46.2, -39.9)
mesh_2.Scale = Vector3.new(1.1, 1.1, 1.1)
mesh_2.Parent = part
weld.Part0 = collar
weld.Name = "Weld"
weld.Part1 = part
weld.Parent = collar
eye.Anchored = true
eye.Size = Vector3.new(2, 2, 2)
eye.BottomSurface = Enum.SurfaceType.Smooth
eye.Material = Enum.Material.SmoothPlastic
eye.Color = Color3.new(0.972549, 0.972549, 0.972549)
eye.Name = "Eye"
eye.TopSurface = Enum.SurfaceType.Smooth
eye.BrickColor = BrickColor.new("Institutional white")
eye.Parent = stuff
eye.CFrame = CFrame.new(9.8, 45.845, -47.125) * CFrame.Angles(0, 0, 0)
mesh_3.MeshType = Enum.MeshType.Sphere
mesh_3.Parent = eye
decal.Texture = "http://www.roblox.com/asset/?id=743271416"
decal.Parent = eye
hood.Size = Vector3.new(2.919, 2.394, 2.891)
hood.BottomSurface = Enum.SurfaceType.Smooth
hood.Material = Enum.Material.SmoothPlastic
hood.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
hood.BrickColor = BrickColor.new("Really black")
hood.TopSurface = Enum.SurfaceType.Smooth
hood.Name = "Hood"
hood.Parent = stuff
hood.CFrame = CFrame.new(9.8, 44.1, -48.7)
mesh_4.Scale = Vector3.new(1.55, 1.44, 1.4)
mesh_4.MeshId = "rbxassetid://16952952"
mesh_4.Parent = hood
pillar.Size = Vector3.new(1, 1, 1)
pillar.Name = "Pillar"
pillar.Material = Enum.Material.Metal
pillar.TopSurface = Enum.SurfaceType.Smooth
pillar.BottomSurface = Enum.SurfaceType.Smooth
pillar.Parent = stuff
pillar.CFrame = CFrame.new(-26.77, 0.5, -37.02)
rock.Size = Vector3.new(2.03, 1.978, 2.057)
rock.BottomSurface = Enum.SurfaceType.Smooth
rock.Name = "Rock"
rock.TopSurface = Enum.SurfaceType.Smooth
rock.Parent = stuff
rock.CFrame = CFrame.new(-0.43, 45.908, -52.56)
core.Name = "Core"
core.Parent = rock
emit.Enabled = false
emit.Lifetime = NumberRange.new(1, 4)
emit.Name = "Emit"
emit.Speed = NumberRange.new(0, 35)
emit.Rotation = NumberRange.new(0, 360)
emit.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.037, 0.754), NumberSequenceKeypoint.new(0.067, 0), NumberSequenceKeypoint.new(1, 0)})
emit.VelocitySpread = 360
emit.Texture = "rbxassetid://281633012"
emit.Acceleration = Vector3.new(0, -15, 0)
emit.Color = ColorSequence.new(Color3.new(0.423529, 0.345098, 0.294118), Color3.new(0.423529, 0.345098, 0.294118))
emit.RotSpeed = NumberRange.new(-25, 25)
emit.SpreadAngle = Vector2.new(360, 360)
emit.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 3), NumberSequenceKeypoint.new(0.255, 3.06), NumberSequenceKeypoint.new(0.649, 2.131), NumberSequenceKeypoint.new(1, 0)})
emit.Parent = core
mesh_5.MeshId =