#include <iostream>
#include <memory>
#include <assert.h>

/* AVL-дерево с методами вставки
 * и удаления по индексу в отсортированной последовательности
 *
 * @tparam T                тип хранимых данных
 * @tparam Comparator       функтор сравнения данных
 */
template<class T, class Comparator>
class AVLTree {
public:
    AVLTree(const AVLTree &) = delete;
    AVLTree &operator=(const AVLTree &) = delete;

    explicit AVLTree();
    size_t insert(const T &new_element);
    T remove_at(size_t pos);

    ~AVLTree();
private:
    //Узел AVL-дерева
    struct Node {
        T data;                     //хранимые данные
        size_t elements_subtree;    //количество элементов в поддереве,
                                    //с корнем в этой вершине(сама вершина не учитывается)
        unsigned char depth;        //глубина поддерева, с корнем в этомй вершине
                                    //(вершина учитывается)

        Node *left;                 //указатель на левое поддерево
        Node *right;                //Указатель на правое поддерево

        int balance() const {
            return (right ? right->depth : 0) - (left ? left->depth : 0);
        }

        void update_depth() {
            unsigned char depth_left = (left ? left->depth : char(0));
            unsigned char depth_right = (right ? right->depth : char(0));

            depth = (depth_left > depth_right ? depth_left : depth_right) + char(1);
        }

        size_t in_left_subtree() {
            return (left ? left->elements_subtree + 1 : 0);
        }

        size_t in_right_subtree() {
            return  (right ? right->elements_subtree + 1 : 0);
        }

        void update_elements_subtree() {
            elements_subtree = in_left_subtree() + in_right_subtree();
        };
    };


    Node *insert_rec(Node*, const T &, size_t *);
    Node *remove_at_rec(Node*, size_t, size_t, T *);

    Node *balance_node(Node*);
    Node *rotate_right(Node*);
    Node *rotate_left(Node*);

    Node *remove_min(Node *, T *);
    Node *remove_max(Node *, T *);
    void remove_subtree(Node *);

    Comparator cmp;
    Node *root;
    size_t element_count;
};

/* Конструктор
 *
 * @tparam T                тип хранимых данных
 * @tparam Comparator       функтор сравнения данных
 */
template<class T, class Comparator>
AVLTree<T, Comparator>::AVLTree() : root(nullptr), element_count(0) {}

/* Операция вставки в AVL-дерево
 *
 * @tparam T                тип хранимых данных
 * @tparam Comparator       функтор сравнения данных
 * @param new_element       элемент, который вставляем
 * @return                  место элемента в отсортированной последовательности
 *                          вставленных элементов
 */
template<class T, class Comparator>
size_t AVLTree<T, Comparator>::insert(const T &new_element) {
    size_t pos = 0;
    element_count++;
    root = insert_rec(root, new_element, &pos);
    return pos;
}

/* Удаление элемента по его индексу в отсортированной последовательности,
 * вставленных элементов
 *
 * @tparam T                тип хранимых данных
 * @tparam Comparator       функтор сравнения данных
 * @param pos               индекс в отсортированной последовательности
 *                          вставленных элементов(c нуля)
 * @return                  копия данных из элемента
 */
template<class T, class Comparator>
T AVLTree<T, Comparator>::remove_at(size_t pos) {
    assert(pos < element_count);

    T deleted;
    element_count--;
    root = remove_at_rec(root, pos, 0, &deleted);
    return deleted;
}

/* Правый поворот поддерева с корнем в node (aka. правый малый поворот)
 *
 * @tparam T                тип хранимых данных
 * @tparam Comparator       функтор сравнения данных
 * @param node              вершина, которую поворачиваем
 * @return                  указатель на новый корень поддерева
 */
template<class T, class Comparator>
typename AVLTree<T, Comparator>::Node *AVLTree<T, Comparator>::rotate_right(Node* node) {
    assert(node && node->left);

    Node *left = node->left;
    node->left = left->right;
    left->right = node;

    node->update_depth();
    left->update_depth();

    //Обновляем количество элементов в поддеревьях,
    //порядок важен!
    node->update_elements_subtree();
    left->update_elements_subtree();

    return left;
}

/* Левый поворот поддерева с корнем в node (aka. левый малый поворот)
 *
 * @tparam T                тип хранимых данных
 * @tparam Comparator       функтор сравнения данных
 * @param node              вершина, которую поворачиваем
 * @return                  указатель на новый корень поддерева
 */
template<class T, class Comparator>
typename AVLTree<T, Comparator>::Node *
AVLTree<T, Comparator>::rotate_left(Node* node) {
    assert(node && node->right);

    Node *right = node->right;
    node->right = right->left;
    right->left = node;
    node->update_depth();
    right->update_depth();

    //Обновляем количество элементов в поддеревьях,
    //порядок важен!
    node->update_elements_subtree();
    right->update_elements_subtree();

    return right;
}

/* Балансировка поддерева с корнем в node
 *
 * @tparam T                тип хранимых данных
 * @tparam Comparator       функтор сравнения данных
 * @param node              корень поддерева, которое балансируем
 * @return                  корень сбалансированного поддерева
 */
template<class T, class Comparator>
typename AVLTree<T, Comparator>::Node *
AVLTree<T, Comparator>::balance_node(Node* node) {
    assert(node);

    node->update_depth(); //сначала нужно обновить глубину

    //aka. большой левый поворот
    if (node->balance() == 2) {
        if (node->right->balance() < 0) {
            node->right = rotate_right(node->right);
        }

        return rotate_left(node);
    }

    //aka. большой правый поворот
    if (node->balance() == -2) {
        if (node->left->balance() > 0) {
            node->left = rotate_left(node->left);
        }

        return rotate_right(node);
    }

    //могли поменятся левое и правое поддеревья без нарушения баланса => нужно тоже обновлять
    node->update_elements_subtree();
    return node;
}

/* Служебная функция рекурсивной вставки
 *
 * @tparam T                тип хранимых данных
 * @tparam Comparator       функтор сравнения данных
 * @param node              текущий узел
 * @param new_element       новые данные
 * @param pos_ptr           указатель, который хранит позицию, на которую встанет элемент
 * @return                  указатель на корень поддерева, в котором находится новый элемент
 */
template<class T, class Comparator>
typename AVLTree<T, Comparator>::Node *
AVLTree<T, Comparator>::insert_rec(Node *node, const T &new_element, size_t *pos_ptr) {
    if (!node) {
        return new Node {new_element, 0, 1, nullptr, nullptr};
    }

    if (cmp(new_element, node->data)) { // new_element < node->data
        node->left = insert_rec(node->left, new_element, pos_ptr);
    } else {
        *pos_ptr += node->in_left_subtree() + 1;    //очевидно, что позиция будет больше, чем позиция текущего на 1,
                                                    //которая задается количеством элементов в его левом поддереве

        node->right = insert_rec(node->right, new_element, pos_ptr);
    }

    node->elements_subtree++;
    return balance_node(node);
}

/* Служебная функция рекурсивного удаления
 *
 * @tparam T                тип хранимых данных
 * @tparam Comparator       функтор сравнения данных
 * @param node              текущий узел
 * @param rem_pos           позиция, на которой нужно удалить элемент
 * @param pos               позиция текущего узла
 * @param value             указатель, который будет указывать на копию удаленного значения
 * @return                  указатель на корень поддерева, в котором удалили элемент
 */
template<class T, class Comparator>
typename AVLTree<T, Comparator>::Node *
AVLTree<T, Comparator>::remove_at_rec(AVLTree::Node *node, size_t rem_pos, size_t pos, T *value) {
    if (!node) {
        return nullptr;
    }

    if (pos + node->in_left_subtree() == rem_pos) {
        *value = node->data;

        unsigned char right_depth = (node->right ? node->right->depth : char(0));
        unsigned char left_depth = (node->left ? node->left->depth : char(0));

        if (!right_depth && !left_depth) {
            delete node;    //лист можно просто удалить
            return nullptr;
        }

        //брать ближайший из более глубокого
        if (right_depth >= left_depth) {
            node->right = remove_min(node->right, &node->data);
        } else {
            node->left = remove_max(node->left, &node->data);
        }
    } else {
        if (pos + node->in_left_subtree() < rem_pos) {
            //Также как и при вставке, очевидно, что элемент уже дальше, чем индекс текущего
            node->right = remove_at_rec(node->right, rem_pos, pos + node->in_left_subtree() + 1, value);
        } else {
            node->left = remove_at_rec(node->left, rem_pos, pos, value);
        }

        node->elements_subtree--;
    }

    return balance_node(node);
}

/* Служебная функция удаления минимума из поддерева
 *
 * @tparam T                тип хранимых данных
 * @tparam Comparator       функтор сравнения данных
 * @param node              текущий узел
 * @return                  указатель на корень поддерева, в котором удалили минимум
 */
template<class T, class Comparator>
typename AVLTree<T, Comparator>::Node *
AVLTree<T, Comparator>::remove_min(AVLTree::Node *node, T *save_data) {
    assert(node);

    if (!node->left) {
        *save_data = node->data;
        Node *right = node->right;
        delete node;

        return right;
  