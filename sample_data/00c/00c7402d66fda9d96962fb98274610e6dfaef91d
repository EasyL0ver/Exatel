/*******
 * Read input from System.in
 * Use: System.out.println to ouput your result to STDOUT.
 * Use: System.err.println to ouput debugging information to STDERR.
 * ***/
package com.isograd.exercise;
import java.util.*;

public class IsoContest {
    
    // A DFS based recursive function that  
    // returns true if a matching for  
    // vertex u is possible 
    static boolean bpm(int N, int[][] horaires, int u,  
                int[] seen, int[] choices, TreeMap<Integer, Integer> choices_time)
    { 
                                            System.err.println("bpm" + u);
            if (seen[u] >=2) {
                return false;
            }
mainloop:
        for (int v = 0; v<2;v++)
        { 


            { 
                  
                seen[u]++;  
  

                int starttime = horaires[u][v];
                Integer prevtime = choices_time.floorKey( starttime );
                Integer nexttime = choices_time.ceilingKey( starttime );
                System.err.println("startime" + starttime);
                System.err.println("prevtime" + prevtime);
                System.err.println("nexttime" + nexttime);
                boolean ok = (prevtime == null || prevtime +60 < starttime) && (nexttime==null || starttime +60 <nexttime);

                if (ok) 
                { 
                                    System.err.println("fastok");
                 } 
                
                if (!ok) {
                List<Integer> blockers = new ArrayList<>(
                		choices_time.subMap(starttime-60, starttime+60)
                		.values());
                System.err.println("blockers" + blockers);

                for (int blocker: blockers) {
                    if (u == blocker) {
                        System.err.println("autoblocker");
                        continue mainloop;
                    }
                }
                boolean allmoved = true;

                for (int blocker: blockers) {
                    if (!bpm(N, horaires, blocker, seen, choices, choices_time)) {
                    	allmoved = false;
                    }
                }
                ok = allmoved;
                }
                
                if (ok) {
                      choices[u] = -1;
                      System.err.println("before remove" + choices_time);
                      System.err.println("key" + horaires[u][0] + "value" + u);
                      System.err.println("key" + horaires[u][1] + "value" + u);
    	choices_time.remove(horaires[u][0], u);
    	choices_time.remove(horaires[u][1], u);
        System.err.println("after remove" + choices_time);

    	             choices[u] = v;
                    choices_time.put(starttime, u);
                	return true;
                }
            } 
        } 
        return false; 
    } 
    
    
public static void main( String[] argv ) throws Exception {
		String  line;
		Scanner sc = new Scanner(System.in);
		int N = Integer.parseInt(sc.nextLine());
		int[] horaires_a = new int[N];
		int[] horaires_b = new int[N];
		int[][] horaires = new int[N][2];
		
		int z=0;
		while(sc.hasNextLine()) {
			line = sc.nextLine();
			String[] split = line.split(" ");
			horaires_a[z] = Integer.parseInt(split[0]);
			horaires_b[z] = Integer.parseInt(split[1]);
			horaires[z][0]= horaires_a[z];
			horaires[z][1]= horaires_b[z];
			z++;
			/* Lisez les données et effectuez votre traitement */
		}
		System.err.println(Arrays.deepToString(horaires));
		
		int[] choices = new int[N];
		for(int i=0;i<N;i++) {
			choices[i] = -1;
		}
		TreeMap<Integer, Integer> choices_time = new TreeMap<>();
  
        // Count of jobs assigned to applicants 
        int result = 0;  
        for (int u = 0; u < N; u++) 
        { 
            System.err.println(Arrays.toString(choices));
            System.err.println(choices_time);
            // Mark all jobs as not seen  
            // for next applicant. 
            int seen[] =new int[N] ; 
            for(int i = 0; i < N; ++i) 
                seen[i] = 0; 
            
            // Find if the applicant 'u' can get a job 
            if (bpm(N, horaires, u, seen, choices, choices_time)) 
                result++;
                
            
        } 
        if (result != N) {
            System.out.print("KO");
        } else {
            for (int choice: choices) {
                System.out.println(choice+1);
            }
        }
	/* Vous pouvez aussi effectuer votre traitement une fois que vous avez lu toutes les données.*/
	}
}